/* eslint-env node, jasmine */
/* eslint-disable no-undefined, class-methods-use-this */

describe("render-prod", () => {
    "use strict";

    var vrdom;
    var PropTypes;

    var namespaces = {
        HTMLnamespace: "http://www.w3.org/1999/xhtml",
        MathMLnamespace: "http://www.w3.org/1998/Math/MathML",
        SVGnamespace: "http://www.w3.org/2000/svg",
        XLinknamespace: "http://www.w3.org/1999/xlink",
        XMLnamespace: "http://www.w3.org/XML/1998/namespace",
        XMLNSnamespace: "http://www.w3.org/2000/xmlns/"
    };

    var slice = Array.prototype.slice;
    var hasProp = Object.prototype.hasOwnProperty;

    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Polyfill
    var assign = typeof Object.assign === "function" ? Object.assign : function(target) {
        if (target == null) { // TypeError if undefined or null
            throw new TypeError("Cannot convert undefined or null to object");
        }

        var to = Object(target);

        for (var index = 1, len = arguments.length; index < len; index++) {
            var nextSource = arguments[index];

            if (nextSource != null) { // Skip over if undefined or null
                for (var nextKey in nextSource) {
                    // Abugs when hasOwnProperty is shadowed
                    if (hasProp.call(nextSource, nextKey)) {
                        to[nextKey] = nextSource[nextKey];
                    }
                }
            }
        }
        return to;
    };

    function removeCommentNodes(nodeList) {
        return slice.call(nodeList).filter(node => node.nodeType !== Node.COMMENT_NODE);
    }

    beforeAll((done) => {
        require.undef("vrdom");

        require(["vrdom"], function() {
            vrdom = arguments[0];
            PropTypes = vrdom.PropTypes;

            done();
        });
    });

    afterAll(() => {
        vrdom.reset();
    });

    it("should create DOM element", () => {
        var element = <div />;
        var domNode = vrdom.render(element, document.createElement("div"));
        expect(domNode.tagName).toBe("DIV");
    });

    it("should create DOM element with attributes and properties", () => {
        var element = <div id="id" className="className" data-custom="data-custom" />;
        var domNode = vrdom.render(element, document.createElement("div"));
        expect(domNode.tagName).toBe("DIV");
        expect(domNode.id).toBe("id");
        expect(domNode.className).toBe("className");
        expect(domNode.getAttribute("data-custom")).toBe("data-custom");
    });

    it("should create DOM element with uppercase attributes and properties", () => {
        var element = <div ID="id" className="className" DATA-CUSTOM="data-custom" contenteditable="true" />;
        var domNode = vrdom.render(element, document.createElement("div"));
        expect(domNode.tagName).toBe("DIV");
        expect(domNode.id).toBe("id");
        expect(domNode.className).toBe("className");
        expect(domNode.getAttribute("data-custom")).toBe("data-custom");
    });

    it("should use first attribute when duplicate attributes", () => {
        spyOn(console, "error");

        var element = <div id="id" ID="id-new" className="className" DATA-CUSTOM="data-custom" />;
        var domNode = vrdom.render(element, document.createElement("div"));

        expect(console.error.calls.count()).toBe(0);

        expect(domNode.tagName).toBe("DIV");
        expect(domNode.id).toBe("id");
        expect(domNode.className).toBe("className");
        expect(domNode.getAttribute("data-custom")).toBe("data-custom");
    });

    it("should create DOM element with children", () => {
        var element = <div id="id" className="className" data-custom="data-custom">child</div>;
        var domNode = vrdom.render(element, document.createElement("div"));
        expect(domNode.tagName).toBe("DIV");
        expect(domNode.id).toBe("id");
        expect(domNode.className).toBe("className");
        expect(domNode.getAttribute("data-custom")).toBe("data-custom");
        expect(domNode.innerHTML).toBe("child");
    });

    it("should create children with children prop", () => {
        var element = <div id="id" className="className" data-custom="data-custom" children="child"></div>;
        var domNode = vrdom.render(element, document.createElement("div"));
        expect(domNode.tagName).toBe("DIV");
        expect(domNode.id).toBe("id");
        expect(domNode.className).toBe("className");
        expect(domNode.getAttribute("data-custom")).toBe("data-custom");
        expect(domNode.innerHTML).toBe("child");
    });

    it("should create children from given children, ignoring children prop", () => {
        var element = <div id="id" className="className" data-custom="data-custom" children="text">child</div>;
        var domNode = vrdom.render(element, document.createElement("div"));
        expect(domNode.tagName).toBe("DIV");
        expect(domNode.id).toBe("id");
        expect(domNode.className).toBe("className");
        expect(domNode.getAttribute("data-custom")).toBe("data-custom");
        expect(domNode.innerHTML).toBe("child");
    });

    it("should render innerHTML", () => {
        var domNode = vrdom.render(<div dangerouslySetInnerHTML={{__html: "<div>child</div>"}} />, document.createElement("div"));
        expect(domNode.firstChild.tagName).toBe("DIV");
        expect(domNode.firstChild.innerHTML).toBe("child");
    });

    it("should render custom-element", () => {
        var domNode = vrdom.render(<custom-element><div>child</div></custom-element>, document.createElement("div"));
        expect(domNode.tagName).toBe("CUSTOM-ELEMENT");
        expect(domNode.firstChild.tagName).toBe("DIV");
        expect(domNode.firstChild.innerHTML).toBe("child");
    });

    it("should render innerHTML in custom-element", () => {
        var domNode = vrdom.render(<custom-element dangerouslySetInnerHTML={{__html: "<div>child</div>"}} />, document.createElement("div"));
        expect(domNode.firstChild.tagName).toBe("DIV");
        expect(domNode.firstChild.innerHTML).toBe("child");
    });

    it("should handle style property", () => {
        spyOn(console, "error");

        var styles = {
            color: "rgb(255, 255, 255)",
            background: "rgb(255, 100, 0)",
            backgroundPosition: "10px 10px",
            "background-size": "cover",
            "line-height": 0.5,
            padding: 5,
            top: 100,
            left: "100%",
            appearance: "auto" // prefixed css prop
        };

        var element = <div style={ styles } />;

        // should not hold reference to style
        expect(element.props.style).not.toBe(styles);

        var container = document.createElement("div");
        var domNode = vrdom.render(element, container);
        var style = domNode.style;

        expect(style.color).toBe("rgb(255, 255, 255)");
        expect(style.backgroundColor).toBe("rgb(255, 100, 0)");
        expect(style.backgroundPosition).toBe("10px 10px");
        expect(style.backgroundSize).toBe("cover");
        expect(style.lineHeight).toBe("0.5");
        expect(style.padding).toBe("5px");
        expect(style.top).toBe("100px");
        expect(style.left).toBe("100%");

        expect(console.error.calls.count()).toBe(0);
    });

    it("should use last style property when duplicated prop", () => {
        spyOn(console, "error");

        var styles = {
            padding: 5,
            top: 100,
            LEFT: "50%",
            left: "100%"
        };

        var element = <div style={ styles } />;

        // should not hold reference to style
        expect(element.props.style).not.toBe(styles);

        var container = document.createElement("div");
        var domNode = vrdom.render(element, container);
        var style = domNode.style;

        expect(console.error.calls.count()).toBe(0);

        expect(style.padding).toBe("5px");
        expect(style.top).toBe("100px");
        expect(style.left).toBe("100%");
    });

    it("should allow custom attributes on custom elements", () => {
        var container = document.createElement("div");
        var domNode = vrdom.render(<custom-element string="value"/>, container);
        expect(domNode.attributes.length).toBe(1);
        expect(domNode.getAttribute("string")).toBe("value");
    });

    it("should render DOM factories", () => {
        var tags = ["a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio", "b", "base", "basefont", "bdi", "bdo", "bgsound", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "font", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "isindex", "kbd", "keygen", "label", "legend", "li", "link", "listing", "main", "map", "mark", "marquee", "math", "menu", "menuitem", "meta", "meter", "multicol", "nav", "nextid", "nobr", "noembed", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "plaintext", "pre", "progress", "q", "rb", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "section", "select", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "tt", "u", "ul", "var", "video", "wbr", "xmp", "altGlyph", "altGlyphDef", "altGlyphItem", "animate", "animateColor", "animateMotion", "animateTransform", "circle", "clipPath", "color-profile", "cursor", "defs", "desc", "ellipse", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "filter", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignObject", "g", "glyph", "glyphRef", "hkern", "line", "linearGradient", "marker", "mask", "metadata", "missing-glyph", "mpath", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "set", "stop", "switch", "symbol", "text", "textPath", "tref", "tspan", "use", "view", "vkern", "discard", "feDropShadow", "hatch", "hatchpath", "mesh", "meshpatch", "meshrow", "solidcolor", "unknown"];
        var ignoredTags = ["acronym", "applet", "basefont", "bgsound", "blink", "center", "dir", "font", "frame", "frameset", "isindex", "listing", "marquee", "multicol", "nextid", "nobr", "noembed", "noframes", "plaintext", "rb", "rtc", "spacer", "strike", "template", "tt", "xmp", "altGlyph", "altGlyphDef", "altGlyphItem", "animate", "animateColor", "animateMotion", "animateTransform", "color-profile", "cursor", "desc", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "filter", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignObject", "glyph", "glyphRef", "hkern", "math", "marker", "metadata", "missing-glyph", "mpath", "set", "slot", "switch", "symbol", "textPath", "tref", "use", "view", "vkern", "discard", "feDropShadow", "hatch", "hatchpath", "mesh", "meshpatch", "meshrow", "solidcolor", "unknown"];
        var DOM = vrdom.DOM;
        var tag, domNode, element;

        for (var i = 0, len = tags.length; i < len; i++) {
            tag = tags[i];
            if (window.isLibrary && ignoredTags.indexOf(tag) !== -1) {
                continue;
            }

            if (!DOM[tag]) {
                expect(DOM).toHaveOwnProperty(tag);
                continue;
            }
            element = DOM[tag]();
            expect(element.type).toBe(tag);

            domNode = vrdom.render(element, document.createElement("div"));
            expect(domNode.tagName.toUpperCase()).toBe(tag.toUpperCase());
        }
    });

    it("should call callback with context after render", () => {
        var calls = 0;
        var element = <div><div>nested child</div></div>;

        var container = document.createElement("div");
        var domNode = vrdom.render(element, container, function() {
            ++calls;
            expect(this.tagName).toBe("DIV"); // eslint-disable-line no-invalid-this
        });

        expect(domNode.tagName).toBe("DIV");
        expect(domNode.firstChild.innerHTML).toBe("nested child");
        expect(calls).toBe(1);
    });

    it("should render Composite Component", () => {
        class CompositeComponent extends vrdom.Component {
            render() {
                return <div />;
            }
        }

        var container = document.createElement("div");
        var instance = vrdom.render(<CompositeComponent />, container);

        expect(instance.constructor).toBe(CompositeComponent);
        expect(instance instanceof CompositeComponent).toBe(true);
        expect(container.children.length).toBe(1);
        expect(container.firstChild.tagName).toBe("DIV");
    });

    it("should not render null children", () => {
        class Component extends vrdom.Component {
            render() {
                return <div>{ null }</div>;
            }
        }

        var container = document.createElement("div");
        vrdom.render(<Component />, container);
        expect(removeCommentNodes(container.firstChild.childNodes).length).toBe(0);
    });

    it("should not render undefined children", () => {
        class Component extends vrdom.Component {
            render() {
                return <div>{ undefined }</div>;
            }
        }

        var container = document.createElement("div");
        vrdom.render(<Component />, container);
        expect(container.firstChild.innerHTML).toBe("");
    });

    it("should handle null in component render", () => {
        class Component extends vrdom.Component {
            render() {
                return null;
            }
        }

        var container = document.createElement("div");
        vrdom.render(<Component />, container);
        expect(removeCommentNodes(container.firstChild.childNodes).length).toBe(0);
    });

    it("should render string children", () => {
        class Component extends vrdom.Component {
            render() {
                return <div>{ "string" }</div>;
            }
        }

        var container = document.createElement("div");
        vrdom.render(<Component />, container);
        expect(container.firstChild.innerHTML).toBe("string");
    });

    it("should render number children", () => {
        class Component extends vrdom.Component {
            render() {
                return <div>{ 0 }</div>;
            }
        }

        var container = document.createElement("div");
        vrdom.render(<Component />, container);
        expect(container.firstChild.innerHTML).toBe("0");
    });

    it("should not render boolean.true children", () => {
        class Component extends vrdom.Component {
            render() {
                return <div>{ true }</div>;
            }
        }

        var container = document.createElement("div");
        vrdom.render(<Component />, container);
        expect(container.firstChild.innerHTML).toBe("");
    });

    it("should not render boolean.false children", () => {
        class Component extends vrdom.Component {
            render() {
                return <div>{ false }</div>;
            }
        }

        var container = document.createElement("div");
        vrdom.render(<Component />, container);
        expect(container.firstChild.innerHTML).toBe("");
    });

    it("should only render defined children in Array", () => {
        class Component extends vrdom.Component {
            render() {
                return <div>{ [null, "string", undefined, 0, false, true, <span>one</span>] }</div>;
            }
        }

        var container = document.createElement("div");
        vrdom.render(<Component />, container);
        expect(container.firstChild.textContent).toBe("string0one");
    });

    it("should render plain object with render method", () => {
        function CompositeComponent(props) {
            return {
                render: function() {
                    return <div>{ props.text }</div>;
                }
            };
        }

        var container = document.createElement("div");
        var instance = vrdom.render(<CompositeComponent text="text" />, container);

        expect(instance.constructor).toBe(Object);
        expect(instance).toEqual(jasmine.any(Object));
        expect(container.firstChild.innerHTML).toBe("text");
    });

    it("should render Composite Component with inner children", () => {
        class CompositeComponent extends vrdom.Component {
            render() {
                return <div><div /></div>;
            }
        }

        var container = document.createElement("div");
        var instance = vrdom.render(<CompositeComponent />, container);

        expect(instance.constructor).toBe(CompositeComponent);
        expect(instance instanceof CompositeComponent).toBe(true);
        expect(container.children.length).toBe(1);
        expect(container.firstChild.tagName).toBe("DIV");
        expect(container.firstChild.children.length).toBe(1);
        expect(container.firstChild.firstChild.tagName).toBe("DIV");
    });

    it("should pass children accross Composite Component layers", () => {
        class Child extends vrdom.Component {
            render() {
                return <div>{ this.props.children }</div>;
            }
        }

        class Parent extends vrdom.Component {
            render() {
                return <Child>{ this.props.children }</Child>;
            }
        }

        class GrandParent extends vrdom.Component {
            render() {
                return <Parent>{ this.props.children }</Parent>;
            }
        }

        var container = document.createElement("div");
        var instance = vrdom.render(<GrandParent>child</GrandParent>, container);

        expect(instance.constructor).toBe(GrandParent);
        expect(instance instanceof GrandParent).toBe(true);
        expect(container.children.length).toBe(1);
        expect(container.firstChild.tagName).toBe("DIV");
        expect(container.firstChild.innerHTML).toBe("child");
    });

    it("should use default props", () => {
        class CompositeComponent extends vrdom.Component {
            static defaultProps = { prop: "prop" };

            render() {
                return <div>{ this.props.prop }</div>;
            }
        }

        var container = document.createElement("div");
        var instance = vrdom.render(<CompositeComponent />, container);

        expect(instance.props.prop).toBe("prop");
        expect(container.firstChild.innerHTML).toBe("prop");
    });

    it("should override default props with falsy defined values", () => {
        class CompositeComponent extends vrdom.Component {
            static defaultProps = { prop: "prop" };

            render() {
                return <span>{ this.props.prop }</span>;
            }
        }

        [null, false, 0, "0", ""].forEach((falsy) => {
            var instance = vrdom.render(<CompositeComponent prop={ falsy } />, document.createElement("div"));
            expect(instance.props.prop).toBe(falsy);
        });
    });

    it("should allow rendering into document fragment", () => {
        var container = document.createDocumentFragment();
        vrdom.render(<div />, container);

        expect(container.childNodes.length).toBe(1);
        expect(container.firstChild.tagName).toBe("DIV");
    });

    it("should treat elements with \"is\" attribute as custom elements", () => {
        var container = document.createElement("div");
        spyOn(document, "createElement").and.callThrough();

        var domNode = vrdom.render(<div is="custom-element" unknown="attribute"/>, container);
        expect(domNode.getAttribute("unknown")).toBe("attribute");
        expect(document.createElement).toHaveBeenCalledWith("div", "custom-element");
    });

    it("should preserve svg namespace", () => {
        class Text extends vrdom.Component {
            render() {
                var props = assign({}, this.props);
                var children = this.props.children;
                delete props.children;

                var args = ["text", this.props];
                if (Array.isArray(children)) {
                    args.push.apply(args, children);
                } else if (children != null) {
                    args.push(children);
                }

                return vrdom.createElement.apply(vrdom, args);
            }
        }

        var element =
            <svg width="200px" height="50px" viewBox="0 0 200 50" zoomAndPan="disable" preserveAspectRatio="none" >
                <Text style={{"fill": "black", "text-anchor": "middle"}} x="100" y="25">Hello World!</Text>
                <rect x="10" y="5" width="20" height="20" fill="blue" />
                <rect x="20" y="10" width="160" height="20" fill="green" opacity="0.5" />
                <rect x="170" y="25" width="20" height="20" fill="blue" />
            </svg>;

        var container = document.createElement("div");
        var svg = vrdom.render(element, container);
        var childNodes = removeCommentNodes(svg.childNodes);

        expect(svg.namespaceURI).toBe(namespaces.SVGnamespace);
        expect(svg.getAttribute("width")).toBe("200px");
        expect(svg.getAttribute("height")).toBe("50px");
        expect(svg.getAttribute("viewBox")).toBe("0 0 200 50");
        expect(svg.getAttribute("zoomAndPan")).toBe("disable");
        expect(svg.getAttribute("preserveAspectRatio")).toContain("none"); // IE return "none meet" instead of "none"

        expect(childNodes.map(node => node.namespaceURI)).toEqual([
            namespaces.SVGnamespace,
            namespaces.SVGnamespace,
            namespaces.SVGnamespace,
            namespaces.SVGnamespace
        ]);
    });

    it("should preserve math namespace", () => {
        class Msup extends vrdom.Component {
            render() {
                var props = assign({}, this.props);
                var children = this.props.children;
                delete props.children;

                var args = ["msup", this.props];
                if (Array.isArray(children)) {
                    args.push.apply(args, children);
                } else if (children != null) {
                    args.push(children);
                }

                return vrdom.createElement.apply(vrdom, args);
            }
        }

        var element =
            <math display="block">
                <mrow>
                    <Msup><mi>x</mi> <mn>2</mn></Msup>
                    <msup><mi>y</mi> <mn>2</mn></msup>
                </mrow>
            </math>;

        var container = document.createElement("div");
        var math = vrdom.render(element, container);
        var childNodes = removeCommentNodes(removeCommentNodes(math.childNodes)[0].childNodes);

        expect(math.namespaceURI).toBe(namespaces.MathMLnamespace);
        expect(math.getAttribute("display")).toBe("block");
        expect(childNodes.map(node => node.namespaceURI)).toEqual([
            namespaces.MathMLnamespace,
            namespaces.MathMLnamespace
        ]);
    });

    it("should pass context to owned children", () => {
        class Child extends vrdom.Component {
            static contextTypes = {
                text: PropTypes.string
            };

            render() {
                return <div>{ this.context.text }</div>;
            }
        }

        class Parent extends vrdom.Component {
            static childContextTypes = {
                text: PropTypes.string
            };

            getChildContext() {
                return {
                    text: "text"
                };
            }

            render() {
                return <div><Child /></div>;
            }
        }

        var container = document.createElement("div");
        vrdom.render(<Parent />, container);
        expect(container.firstChild.firstChild.innerHTML).toBe("text");
    });

    it("should pass context to not owned children", () => {
        class Child extends vrdom.Component {
            static contextTypes = {
                text: PropTypes.string
            };

            render() {
                return <div>{ this.context.text }</div>;
            }
        }

        class Parent extends vrdom.Component {
            static childContextTypes = {
                text: PropTypes.string
            };

            getChildContext() {
                return {
                    text: "text"
                };
            }

            render() {
                return <div>{ this.props.children }</div>;
            }
        }

        var container = document.createElement("div");
        vrdom.render(<Parent><Child /></Parent>, container);
        expect(container.firstChild.firstChild.innerHTML).toBe("text");
    });

    it("should handle undefined return by getChildContext", () => {
        class Child extends vrdom.Component {
            static contextTypes = {
                text: PropTypes.string
            };

            render() {
                expect(this.context).toEqual({ text: undefined });
                return <div>{ this.context.text }</div>;
            }
        }

        class Parent extends vrdom.Component {
            static childContextTypes = {
                text: PropTypes.string
            };

            getChildContext() {} // eslint-disable-line no-empty-function

            render() {
                return <div>{ this.props.children }</div>;
            }
        }

        var container = document.createElement("div");
        vrdom.render(<Parent><Child /></Parent>, container);
        expect(container.firstChild.firstChild.innerHTML).toBe("");
    });

    it("should let context pass through", () => {
        var child = null;

        class Child extends vrdom.Component {
            static contextTypes = {
                text: PropTypes.string
            };

            render() {
                child = this;
                return <div>{ this.context.text }</div>;
            }
        }

        class Parent extends vrdom.Component {
            render() {
                return this.props.children;
            }
        }

        class GrandParent extends vrdom.Component {
            static childContextTypes = {
                text: PropTypes.string
            };

            getChildContext() {
                return {
                    text: "text"
                };
            }

            render() {
                return this.props.children;
            }
        }

        var container = document.createElement("div");
        vrdom.render(<GrandParent><Parent><Child /></Parent></GrandParent>, container);

        // check context before/after render
        expect(container.firstChild.innerHTML).toBe("text");
        expect(child.context).toEqual({text: "text"});
        child = null;
    });

    it("should cascade context over children", () => {
        var child = null;
        var parent = null;

        class Child extends vrdom.Component {
            static contextTypes = {
                "grand-parent": PropTypes.string,
                "parent": PropTypes.string
            };

            render() {
                child = this;
                return <div>{ this.context["grand-parent"] } : { this.context.parent }</div>;
            }
        }

        class Parent extends vrdom.Component {
            static contextTypes = {
                "grand-parent": PropTypes.string
            };

            static childContextTypes = {
                "grand-parent": PropTypes.string,
                "parent": PropTypes.string
            };

            getChildContext() {
                return {
                    "grand-parent": "my-parent",
                    "parent": "parent"
                };
            }

            render() {
                parent = this;
                return this.props.children;
            }
        }

        class GrandParent extends vrdom.Component {
            static childContextTypes = {
                "grand-parent": PropTypes.string
            };

            getChildContext() {
                return {
                    "grand-parent": "grand-parent"
                };
            }

            render() {
                return this.props.children;
            }
        }

        var container = document.createElement("div");
        vrdom.render(<GrandParent><Parent><Child /></Parent></GrandParent>, container);

        // check context before/after render
        expect(container.firstChild.textContent).toBe("my-parent : parent");
        expect(child.context).toEqual({"grand-parent": "my-parent", parent: "parent"});
        expect(parent.context).toEqual({"grand-parent": "grand-parent"});
        child = null;
        parent = null;
    });

    describe("Warnings", () => {
        it("should not warn when changing props in constructor", () => {
            class Component extends vrdom.Component {
                constructor(props, context) {
                    super(props, context);
                    this.props = {};
                }

                render() {
                    return <div />;
                }
            }

            spyOn(console, "error");
            vrdom.render(<Component />, document.createElement("div"));
            expect(console.error.calls.count()).toBe(0);

        });

        it("should not warn when changing context in constructor", () => {
            class Component extends vrdom.Component {
                constructor(props, context) {
                    super(props, context);
                    this.context = {};
                }

                render() {
                    return <div />;
                }
            }

            spyOn(console, "error");
            vrdom.render(<Component />, document.createElement("div"));
            expect(console.error.calls.count()).toBe(0);

        });

        it("should not warn when componentDidUnmount is defined", () => {
            class Component extends vrdom.Component {
                componentDidUnmount(){
                    // do nothing
                }

                render() {
                    return <div />;
                }
            }

            spyOn(console, "error");
            vrdom.render(<Component />, document.createElement("div"));
            expect(console.error.calls.count()).toBe(0);

        });

        it("should not warn if rendering in document.body", (done) => {
            var iframe = document.createElement("iframe");

            // on IE9, body is only available at onload
            iframe.onload = function() {
                spyOn(console, "error");

                vrdom.render(<div />, iframe.contentDocument.body);

                expect(console.error.calls.count()).toBe(0);

                document.body.removeChild(iframe);
                done();
            };

            document.body.appendChild(iframe);
        });

        it("should not prevent setting invalid attribute name", () => {
            spyOn(console, "error");

            var container, element;

            for (var i = 0; i < 2; i++) {
                container = document.createElement("div");
                element = vrdom.createElement("custom-component", {"\" onclick=\"alert(22)\" \"": "selected"});
                vrdom.render(element, container);
            }

            expect(console.error.calls.count()).toBe(0);

            vrdom.reset();
        });

        it("should not prevent directly setting property `innerHTML`", () => {
            spyOn(console, "error");

            var container = document.createElement("div");
            vrdom.render(<div innerHTML="inner" />, container);

            expect(console.error.calls.count()).toBe(0);
        });

        it("should handle null dangerouslySetInnerHTML", () => {
            var domNode = vrdom.render(<div dangerouslySetInnerHTML={ null }>child</div>, document.createElement("div"));
            expect(domNode.tagName).toBe("DIV");
            expect(domNode.innerHTML).toBe("child");
        });

        it("should not warn component is `contentEditable` and contains `children`", () => {
            spyOn(console, "error");
            vrdom.render(<div contentEditable={ true }>child</div>, document.createElement("div"));
            expect(console.error.calls.count()).toBe(0);
        });

        it("should suppressContentEditableWarning", () => {
            spyOn(console, "error");
            vrdom.render(<div contentEditable={ true } suppressContentEditableWarning={ true }>child</div>, document.createElement("div"));
            expect(console.error.calls.count()).toBe(0);
        });

        it("should not warn for vrdom.render in render", () => {
            spyOn(console, "error");

            var parentContainer = document.createElement("div");
            var childContainer = document.createElement("div");

            class Child extends vrdom.Component {
                render() {
                    return <div />;
                }
            }

            class Parent extends vrdom.Component {
                render() {
                    vrdom.render(<Child />, childContainer);
                    return <div />;
                }
            }

            vrdom.render(<Parent />, parentContainer);
            expect(console.error.calls.count()).toBe(0);
        });

    });

    describe("Errors", () => {
        it("should not throw on invalid callback", () => {
            function Dummy() {
                this.key0 = 0;
                this.key1 = 1;
            }

            var container = document.createElement("div");

            expect(() => vrdom.render(<div />, container, "string")).not.toThrow();
            expect(() => vrdom.render(<div />, container, {})).not.toThrow();
            expect(() => vrdom.render(<div />, container, new Dummy())).not.toThrow();
        });

        it("should not throw on invalid container", () => {
            var container = document.createElement("div");

            [true, false, 0, 1, null, undefined, Function.prototype, {}, [container]].forEach((container) => {
                expect(() => vrdom.render(<div></div>, container)).not.toThrow();
            });
        });

        it("shoud throw on invalid elements", () => {
            var container = document.createElement("container");

            expect(() => {
                vrdom.render({}, container);
            }).not.toThrow();

            expect(() => {
                vrdom.render(<div>{ {} }</div>, container);
            }).not.toThrow();

            expect(() => {
                class CompositeComponent extends vrdom.Component {
                    render() {
                        return <div>{ {} }</div>;
                    }
                }

                vrdom.render(<CompositeComponent />, container);
            }).not.toThrow();

            expect(() => {
                vrdom.render("div", container);
            }).not.toThrow();

            class CompositeComponent extends vrdom.Component {
                render() {
                    return "div";
                }
            }

            expect(() => {
                vrdom.render(CompositeComponent, container);
            }).not.toThrow();

            expect(() => {
                vrdom.render(<CompositeComponent />, container);
            }).not.toThrow();

            var Undefined;
            expect(() => vrdom.render(<Undefined />, document.createElement("div"))).not.toThrow();

            var Null = null;
            expect(() => vrdom.render(<Null />, document.createElement("div"))).not.toThrow();
        });

        it("should not throw when adding children in elements", () => {
            expect(() => {
                var container = document.createElement("div");
                vrdom.render(<input>children</input>, container);
            }).not.toThrow();
        });

        it("should not throw when setting innerHTML in elements", () => {
            expect(() => {
                var container = document.createElement("div");
                vrdom.render(<input dangerouslySetInnerHTML={{__html: "inner"}} />, container);
            }).not.toThrow();
        });

        it("should not prevent setting children and innerHTML", () => {
            var container = document.createElement("div");

            expect(() => {
                vrdom.render(<div dangerouslySetInnerHTML={{__html: "inner"}}>child</div>, container);
            }).not.toThrow();

            expect(() => {
                vrdom.render(<div dangerouslySetInnerHTML={{__html: null}}>child</div>, container);
            }).not.toThrow();
        });

        it("should not check dangerouslySetInnerHTML", () => {
            var container = document.createElement("div");
            [0, "string", Function.prototype, {}].forEach((html) => {
                expect(() => {
                    vrdom.render(<div dangerouslySetInnerHTML={ html } />, container);
                }).not.toThrow();
            });
        });

        it("should not expect stype to be a mapping from style properties to values", () => {
            [true, false, 0, 1, "display: none"].forEach((style) => {
                expect(() => {
                    vrdom.render(<div style={ style } />, document.createElement("div"));
                }).not.toThrow();
            });
        });

        it("should not expect stype to be a mapping from style properties to values and add owner info", () => {
            [true, false, 0, 1, "display: none"].forEach((style) => {
                expect(() => {
                    class CompositeComponent extends vrdom.Component {
                        render() {
                            return <div style={ style }></div>;
                        }
                    }

                    vrdom.render(<CompositeComponent />, document.createElement("div"));
                }).not.toThrow();
            });
        });

        it("should not reject invalid tagName", () => {
            ["a space tag", "><script><script><"].forEach((tagName) => {
                expect(() => {
                    var element = vrdom.createElement(tagName);
                    vrdom.render(element, document.createElement("div"));
                }).not.toThrow();
            });
        });

        it("should not throw when childContextTypes is not defined", () => {
            class Child extends vrdom.Component {
                static contextTypes = {
                    text: PropTypes.string
                };

                render() {
                    return <div>{ this.context.text }</div>;
                }
            }

            class Parent extends vrdom.Component {
                getChildContext() {
                    return {
                        text: "text"
                    };
                }

                render() {
                    return <div>{ this.props.children }</div>;
                }
            }

            expect(() => {
                vrdom.render(<Parent><Child /></Parent>, document.createElement("div"));
            }).not.toThrow();
        });

        it("should not throw when getChildContext has a key not in childContextTypes", () => {
            class Child extends vrdom.Component {
                static contextTypes = {
                    text: PropTypes.string
                };

                render() {
                    return <div>{ this.context.text }</div>;
                }
            }

            class Parent extends vrdom.Component {
                static childContextTypes = {
                    text: PropTypes.string
                };

                getChildContext() {
                    return {
                        textn: "text"
                    };
                }

                render() {
                    return <div>{ this.props.children }</div>;
                }
            }

            expect(() => {
                vrdom.render(<Parent><Child /></Parent>, document.createElement("div"));
            }).not.toThrow();
        });

    });
});
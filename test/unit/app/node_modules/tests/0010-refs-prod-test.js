/* eslint-env node, jasmine */
/* eslint-disable no-undefined, class-methods-use-this, no-return-assign */

describe("refs-prod", () => {
    "use strict";

    var vrdom;

    beforeAll((done) => {
        require.undef("vrdom");

        require(["vrdom"], function() {
            vrdom = arguments[0];

            done();
        });
    });

    afterAll(() => {
        vrdom.reset();
    });

    it("should not throw when ref string with no owner", () => {
        expect(() => vrdom.render(<div ref="node" />, document.createElement("div"))).not.toThrow();
    });

    it("should allow ref function without owner", () => {
        var domNode;
        var container = document.createElement("div");

        vrdom.render(<div ref={ (node) => domNode = node } />, container);
        expect(domNode).toBe(container.firstChild);
        domNode = null;
    });

    it("should allow ref string in Composite Component", () => {
        var container = document.createElement("div");
        var calls = 0;

        class Component extends vrdom.Component {
            render() {
                return <div ref="node" />;
            }

            componentDidMount() {
                // should be availabe in componentDidMount
                expect(this.refs.node).toBe(container.firstChild);
                ++calls;
            }
        }

        var instance = vrdom.render(<Component />, container);

        expect(instance.refs.node).toBe(container.firstChild);
        expect(calls).toBe(1);
        container = null;
    });

    it("should allow ref function in Composite Component", () => {
        var container = document.createElement("div");
        var calls = 0;
        var domNode;

        class Component extends vrdom.Component {
            render() {
                return <div ref={ (node) => domNode = node } />;
            }

            componentDidMount() {
                expect(domNode).toBe(container.firstChild);
                ++calls;
            }
        }

        vrdom.render(<Component />, container);

        expect(domNode).toBe(container.firstChild);
        expect(calls).toBe(1);
        domNode = null;
    });

    it("should change ref string when Component changes", () => {
        class Component extends vrdom.Component {
            constructor(props) {
                super(props);
                this.state = {};
            }

            render() {
                if (this.state.a) {
                    return <a ref="node" />;
                }

                if (this.props.b) {
                    return <b ref="node" />;
                }

                return <div ref="node" />;
            }
        }

        var container = document.createElement("div");
        var instance = vrdom.render(<Component />, container);
        expect(instance.refs.node).toBe(container.firstChild);
        expect(container.firstChild.tagName).toBe("DIV");

        vrdom.render(<Component b={ true } />, container);
        expect(instance.refs.node).toBe(container.firstChild);
        expect(container.firstChild.tagName).toBe("B");

        instance.setState({ a: true });
        expect(instance.refs.node).toBe(container.firstChild);
        expect(container.firstChild.tagName).toBe("A");
    });

    it("should allow ref string in nested Composite Component", () => {
        var container = document.createElement("div");
        var preserved = {};
        var calls = 0;

        class Child extends vrdom.Component {
            render() {
                return <div ref="node" />;
            }

            componentDidMount() {
                // should be availabe in componentDidMount
                expect(this.refs.node).toBe(container.firstChild);
                ++calls;
            }
        }

        class Parent extends vrdom.Component {
            render() {
                return <Child preserved={ preserved } ref="child" />;
            }

            componentDidMount() {
                // should be availabe in componentDidMount
                expect(this.refs.child).toEqual(jasmine.any(Child));
                ++calls;
            }
        }

        var instance = vrdom.render(<Parent />, container);

        expect(instance.refs.child).toEqual(jasmine.any(Child));
        expect(instance.refs.child.props.preserved).toBe(preserved);
        expect(instance.refs.child.refs.node).toBe(container.firstChild);
        expect(calls).toBe(2);
        container = null;
    });

    it("should allow ref function in nested Composite Component", () => {
        var container = document.createElement("div");
        var preserved = {};
        var calls = 0;
        var domNode;
        var child;

        class Child extends vrdom.Component {
            render() {
                return <div ref={ (node) => domNode = node } />;
            }

            componentDidMount() {
                // should be availabe in componentDidMount
                expect(domNode).toBe(container.firstChild);
                ++calls;
            }
        }

        class Parent extends vrdom.Component {
            render() {
                return <Child preserved={ preserved } ref={ (instance)=> child = instance } />;
            }

            componentDidMount() {
                // should be availabe in componentDidMount
                expect(child).toEqual(jasmine.any(Child));
                ++calls;
            }
        }

        vrdom.render(<Parent />, container);

        expect(child).toEqual(jasmine.any(Child));
        expect(child.props.preserved).toBe(preserved);
        expect(domNode).toBe(container.firstChild);
        expect(calls).toBe(2);
        container = null;
    });

    it("should not set ref on unmounted", () => {
        var calls = 0;
        var setRef = jasmine.createSpy("setRef");

        class Child extends vrdom.Component {
            render() {
                return <div />;
            }

            componentDidMount() {
                ++calls;
            }
        }

        class Parent extends vrdom.Component {
            render() {
                // child do not render children
                // therefore, ref should not be setted
                return <Child><div ref="node"></div><div ref={ setRef }></div></Child>;
            }

            componentDidMount() {
                expect(this.refs && this.refs.node).toBe(undefined);
                ++calls;
            }
        }

        var container = document.createElement("div");
        var instance = vrdom.render(<Parent />, container);

        expect(instance.refs && instance.refs.node).toBe(undefined);
        expect(calls).toBe(2);
        expect(setRef.calls.count()).toBe(0);
    });

    it("should unset ref when unmounting", () => {
        class Component extends vrdom.Component {
            render() {
                return <div ref="node" />;
            }
        }

        var container = document.createElement("div");
        var instance = vrdom.render(<Component />, container);
        vrdom.unmountComponentAtNode(container);
        expect(instance.refs).toEqual({});
    });

    it("should call ref function with null when unmounted", () => {
        var domNode;

        class Component extends vrdom.Component {
            render() {
                return <div ref={ (node) => domNode = node } />;
            }
        }

        var container = document.createElement("div");
        vrdom.render(<Component />, container);
        vrdom.unmountComponentAtNode(container);
        expect(domNode).toBe(null);
    });

    it("should call ref function with null after top component get unmounted", () => {
        var domNode;
        var container = document.createElement("div");

        function setRef(node) {
            domNode = node;
        }

        vrdom.render(<div ref={ setRef } />, container);
        vrdom.unmountComponentAtNode(container);
        expect(domNode).toBe(null);
    });

    it("should unset child ref to null when unmounting child", () => {
        var preserved = {};

        class Child extends vrdom.Component {
            render() {
                return this.props.unmount ? null : <div ref="node" />;
            }
        }

        class Parent extends vrdom.Component {
            render() {
                return <Child preserved={ preserved } unmount={ this.props.unmount } ref="child" />;
            }
        }

        var container = document.createElement("div");
        var instance = vrdom.render(<Parent />, container);
        vrdom.render(<Parent unmount={ true } />, container);

        expect(instance.refs.child).toEqual(jasmine.any(Child));
        expect(instance.refs.child.props.preserved).toBe(preserved);
        expect(instance.refs.child.refs.node).toBe(undefined);

        vrdom.unmountComponentAtNode(container);
        expect(instance.refs).toEqual({});
    });

    it("should call child ref function with null when unmounting", () => {
        var preserved = {};
        var domNode;
        var child;

        function setChildRef(instance) {
            child = instance;
        }

        function setNodeRef(node) {
            domNode = node;
        }

        class Child extends vrdom.Component {
            render() {
                return this.props.unmount ? null : <div ref={ setNodeRef } />;
            }
        }

        class Parent extends vrdom.Component {
            render() {
                return <Child preserved={ preserved } unmount={ this.props.unmount } ref={ setChildRef } />;
            }
        }

        var container = document.createElement("div");
        vrdom.render(<Parent />, container);
        vrdom.render(<Parent unmount={ true } />, container);

        expect(child).toEqual(jasmine.any(Child));
        expect(child.props.preserved).toBe(preserved);
        expect(domNode).toBe(null);

        vrdom.unmountComponentAtNode(container);
        expect(child).toBe(null);
        expect(domNode).toBe(null);
    });

    it("should call ref on ref change", () => {
        var domNode1, domNode2;
        var container = document.createElement("div");
        vrdom.render(<div ref={(node) => domNode1 = node} />, container);
        vrdom.render(<div ref={(node) => domNode2 = node} />, container);

        expect(domNode1).toBe(null);
        expect(domNode2).toBe(container.firstChild);
    });

});
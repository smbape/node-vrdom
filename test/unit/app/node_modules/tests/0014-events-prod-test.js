/* eslint-env node, jasmine */
/* eslint-disable no-undefined, class-methods-use-this, guard-for-in */

describe("events-prod", () => {
    "use strict";

    var vrdom;
    var Triggers;

    var eventNames = {
        Change: true,
        Click: true,
        Copy: true,
        Cut: true,
        KeyDown: true,
        KeyPress: true,
        KeyUp: true,
        MouseDown: true,
        MouseMove: true,
        MouseOut: true,
        MouseOver: true,
        MouseUp: true,
        Paste: true,
        Scroll: true,
        Wheel: true
    };

    beforeAll((done) => {
        require.undef("vrdom");

        require(["vrdom", "Triggers"], function() {
            vrdom = arguments[0];
            Triggers = arguments[1](vrdom);

            done();
        });
    });

    afterAll(() => {
        vrdom.reset();
    });

    it("should handle event on DOM element", () => {
        var count, props;
        var container = document.createElement("div");

        for (var name in eventNames) {
            count = 0;
            props = {};
            props["on" + name] = increase.bind(null, name.toLowerCase());
            vrdom.render(<div { ...props } />, container);
            Triggers[name.toLowerCase()](container.firstChild);
            expect(count).toBe(1);
            vrdom.unmountComponentAtNode(container);
        }

        function increase(type, evt) {
            expect(evt.type).toBe(type);
            expect(evt.bubbles).toBe(true);
            expect(evt.which).toBe(/^key/.test(type) ? "E".charCodeAt(0) : undefined);
            expect(evt.target).toBe(container.firstChild);
            expect(evt.currentTarget).toBe(container.firstChild);
            count++;
        }
    });

    it("should handle event in composite element", () => {
        var count, props;
        var container = document.createElement("div");

        class Component extends vrdom.Component {
            render() {
                return <div { ...this.props } />;
            }
        }

        for (var name in eventNames) {
            count = 0;
            props = {};
            props["on" + name] = increase.bind(null, name.toLowerCase());
            vrdom.render(<Component { ...props } />, container);
            Triggers[name.toLowerCase()](container.firstChild);
            expect(count).toBe(1);
            vrdom.unmountComponentAtNode(container);
        }

        function increase(type, evt) {
            expect(evt.type).toBe(type);
            expect(evt.bubbles).toBe(true);
            expect(evt.which).toBe(/^key/.test(type) ? "E".charCodeAt(0) : undefined);
            expect(evt.target).toBe(container.firstChild);
            expect(evt.currentTarget).toBe(container.firstChild);
            count++;
        }
    });

    it("should bubble event", () => {
        var count, parentProps, childProps;
        var container = document.createElement("div");

        class Child extends vrdom.Component {
            render() {
                return <div { ...this.props }><div /></div>;
            }
        }

        class Parent extends vrdom.Component {
            render() {
                return <div { ...this.props.parentProps }><Child { ...this.props.childProps } /></div>;
            }
        }

        for (var name in eventNames) {
            count = 0;

            parentProps = {};
            parentProps["on" + name] = increase.bind(null, 1);

            childProps = {};
            childProps["on" + name] = increase.bind(null, 2);

            vrdom.render(<Parent parentProps={ parentProps } childProps={ childProps } />, container);
            Triggers[name.toLowerCase()](container.firstChild.firstChild.firstChild);
            expect(count).toBe(2);
            vrdom.unmountComponentAtNode(container);
        }

        function increase(level, evt) {
            if (level === 1) {
                expect(evt.currentTarget).toBe(container.firstChild);
            } else {
                expect(evt.currentTarget).toBe(container.firstChild.firstChild);
            }

            expect(evt.target).toBe(container.firstChild.firstChild.firstChild);
            count++;
        }
    });

    it("should stop propagation", () => {
        var count, propagationStopped, parentProps, childProps;
        var container = document.createElement("div");

        class Child extends vrdom.Component {
            render() {
                return <div { ...this.props }><div /></div>;
            }
        }

        class Parent extends vrdom.Component {
            render() {
                return <div { ...this.props.parentProps }><Child { ...this.props.childProps } /></div>;
            }
        }

        for (var name in eventNames) {
            count = 0;
            propagationStopped = false;

            parentProps = {};
            parentProps["on" + name] = increase;

            childProps = {};
            childProps["on" + name] = stopPropagation;

            vrdom.render(<Parent parentProps={ parentProps } childProps={ childProps } />, container);
            Triggers[name.toLowerCase()](container.firstChild.firstChild.firstChild);
            expect(count).toBe(1);
            expect(propagationStopped).toBe(true);
            vrdom.unmountComponentAtNode(container);
        }

        function stopPropagation(evt) {
            evt.stopPropagation();
            propagationStopped = true;
            count++;
        }

        function increase() {
            count++;
        }

    });

    it("should unregister event on DOM element ", () => {
        var count, props, domNode;
        var container = document.createElement("div");
        var tagName;

        for (var name in eventNames) {
            count = 0;
            props = {};
            props["on" + name] = increase;
            tagName = name === "Change" || name === "KeyPress" ? "input" : "div";

            domNode = vrdom.render(vrdom.createElement(tagName, props), container);
            Triggers[name.toLowerCase()](domNode);
            if (count !== 1) {
                expect(name).toBe("handled");
            } else {
                expect(count).toBe(1);
            }

            // removing listener should unregister event
            vrdom.render(vrdom.createElement(tagName, null), container);
            Triggers[name.toLowerCase()](domNode);
            expect(count).toBe(1);

            // re-adding listener should re-register event
            vrdom.render(vrdom.createElement(tagName, props), container);
            Triggers[name.toLowerCase()](domNode);
            expect(count).toBe(2);

            // unmounting component should unregister event
            vrdom.unmountComponentAtNode(container);
            Triggers[name.toLowerCase()](domNode);
            expect(count).toBe(2);

            domNode = null;
        }

        function increase() {
            count++;
        }
    });

    it("should prevent default on submit", () => {
        var count = 0;

        class Component extends vrdom.Component {
            handleSubmit(evt) {
                expect(evt.isDefaultPrevented()).toBe(false);
                evt.preventDefault();
                expect(evt.isDefaultPrevented()).toBe(true);
                count++;
            }

            render() {
                return <form onSubmit={ this.handleSubmit }><input type="submit" /></form>;
            }
        }

        // http://stackoverflow.com/questions/645555/should-jquerys-form-submit-not-trigger-onsubmit-within-the-form-tag#645556
        var container = document.createElement("div");
        document.body.appendChild(container);
        vrdom.render(<Component />, container);
        container.firstChild.firstChild.click();
        expect(count).toEqual(1);
        vrdom.unmountComponentAtNode(container);
        document.body.removeChild(container);
    });

    it("should prevent default on submit when false returned", () => {
        var count = 0;

        class Component extends vrdom.Component {
            handleSubmit() {
                count++;
                return false;
            }

            render() {
                return <form onSubmit={ this.handleSubmit }><input type="submit" /></form>;
            }
        }

        // http://stackoverflow.com/questions/645555/should-jquerys-form-submit-not-trigger-onsubmit-within-the-form-tag#645556
        var container = document.createElement("div");
        document.body.appendChild(container);
        vrdom.render(<Component />, container);
        container.firstChild.firstChild.click();
        expect(count).toEqual(1);
        vrdom.unmountComponentAtNode(container);
        document.body.removeChild(container);
    });

    it("should bubble and prevent default on submit", () => {
        var count = 0;

        class Child extends vrdom.Component {
            render() {
                return <form><input type="submit" /></form>;
            }
        }

        class Parent extends vrdom.Component {
            handleSubmit(evt) {
                evt.preventDefault();
                count++;
            }

            render() {
                return <div onSubmit={ this.handleSubmit }><Child /></div>;
            }
        }

        // http://stackoverflow.com/questions/645555/should-jquerys-form-submit-not-trigger-onsubmit-within-the-form-tag#645556
        var container = document.createElement("div");
        document.body.appendChild(container);
        vrdom.render(<Parent />, container);
        container.firstChild.firstChild.firstChild.click();
        expect(count).toEqual(1);
        vrdom.unmountComponentAtNode(container);
        document.body.removeChild(container);
    });

    it("should bubble and prevent default on submit when false returned", () => {
        var count = 0;
        var childCount = 0;

        class Child extends vrdom.Component {
            handleSubmit() {
                childCount++;
            }

            render() {
                return <form onSubmit={ this.handleSubmit }><input type="submit" /></form>;
            }
        }

        class Parent extends vrdom.Component {
            handleSubmit() {
                count++;
                return false;
            }

            render() {
                return <div onSubmit={ this.handleSubmit }><Child /></div>;
            }
        }

        // http://stackoverflow.com/questions/645555/should-jquerys-form-submit-not-trigger-onsubmit-within-the-form-tag#645556
        var container = document.createElement("div");
        document.body.appendChild(container);
        vrdom.render(<Parent />, container);
        container.firstChild.firstChild.firstChild.click();
        expect(childCount).toEqual(1);
        expect(count).toEqual(1);
        vrdom.unmountComponentAtNode(container);
        document.body.removeChild(container);
    });

    it("should catch on error", (done) => {
        // http://stackoverflow.com/questions/645555/should-jquerys-form-submit-not-trigger-onsubmit-within-the-form-tag#645556
        var container = document.createElement("div");
        document.body.appendChild(container);

        var count = 0;

        class Component extends vrdom.Component {
            handleError(evt) {
                evt.preventDefault();
                count++;
                expect(count).toEqual(1);
                vrdom.unmountComponentAtNode(container);
                document.body.removeChild(container);
                container = null;

                // done will call next test synchronously
                // keeping vrdom in handling state until next text ends
                // to prevent that, call done asynchrounously
                setTimeout(done, 1);
                done = null;
            }

            render() {
                var src = "http://" + Math.random().toString(36).slice(2) + ".127.0.0.1/video.mp4";
                return (
                    <video onError={ this.handleError }>
                        <source src={ src } type="video/mp4" />
                    </video>
                );
            }
        }

        vrdom.render(<Component />, container);
    });

    it("should bubble on error", (done) => {
        // http://stackoverflow.com/questions/645555/should-jquerys-form-submit-not-trigger-onsubmit-within-the-form-tag#645556
        var container = document.createElement("div");
        document.body.appendChild(container);

        var count = 0;

        class Child extends vrdom.Component {
            render() {
                var src = "http://" + Math.random().toString(36).slice(2) + ".127.0.0.1/video.mp4";
                return (
                    <video>
                        <source src={ src } type="video/mp4" />
                    </video>
                );
            }
        }

        class Parent extends vrdom.Component {
            handleError(evt) {
                evt.preventDefault();
                count++;
                expect(count).toEqual(1);
                vrdom.unmountComponentAtNode(container);
                document.body.removeChild(container);
                container = null;

                // done will call next test synchronously
                // keeping vrdom in handling state until next text ends
                // to prevent that, call done asynchrounously
                setTimeout(done, 1);
                done = null;
            }

            render() {
                return <div onError={ this.handleError }><Child /></div>;
            }
        }

        vrdom.render(<Parent />, container);
    });

    it("should listen for resize on window if not a media element", () => {
        var count = 0;
        var container = document.createElement("div");
        vrdom.render(<div onResize={ () => ++count } />, container);
        Triggers.resize(window);
        expect(count).toBe(1);
        vrdom.unmountComponentAtNode(container);
        Triggers.resize(window);
        expect(count).toBe(1);
    });

    it("should listen for resize on media element", () => {
        var count = 0;
        var container = document.createElement("div");
        var domNode = vrdom.render(<video onResize={ () => ++count }>
            <source src={"http://" + Math.random().toString(36).slice(2) + ".127.0.0.1/video.mp4"} type="video/mp4" />
        </video>, container);
        Triggers.resize(domNode);
        expect(count).toBe(1);
        vrdom.unmountComponentAtNode(container);
        Triggers.resize(window);
        expect(count).toBe(1);
    });

    it("should set state after event handling", () => {
        var logs = [];

        function logger(msg) {
            return function() {
                logs.push(msg);
            };
        }

        var Component = vrdom.createClass({
            getInitialState: function() {
                return { handled: "false", value: "value" };
            },

            handleBubbleClick: function() {
                logs.push("handle-bubble start");

                this.setState(function() {
                    logs.push("setState-bubble");
                    return { "handled-bubble": "true" };
                }, logger("setState-bubble-cb"));

                logs.push("handle-bubble end");
            },

            handleClick: function() {
                logs.push("handle-click start");

                this.setState(function() {
                    logs.push("setState");
                    return { handled: "true" };
                }, logger("setState-cb"));

                this.refs.input.value = "changed";
                Triggers.change(this.refs.input);

                logs.push("handle-click end");
            },

            handleChange: function(evt) {
                logs.push("handle-change start");

                var value = evt.target.value;
                this.setState(function() {
                    logs.push("setState-change");
                    return { value: value };
                }, logger("setState-change-cb"));

                this.forceUpdate(function() {
                    logs.push("forceUpdate-change-cb");
                });

                logs.push("handle-change end");
            },

            render: function() {
                return (
                    <div onClick={ this.handleBubbleClick }>
                        <div onClick={ this.handleClick }>{ this.state.handled }</div>
                        <input ref="input" type="text" value={ this.state.handled } onChange={ this.handleChange } />
                    </div>
                );
            },

            componentWillUpdate: logger("componentWillUpdate"),
            componentDidUpdate: logger("componentDidUpdate")
        });

        var container = document.createElement("div");
        var instance = vrdom.render(<Component />, container);

        expect(container.firstChild.firstChild.innerHTML).toBe("false");

        expect(instance.state).toEqual({
            handled: "false",
            value: "value"
        });

        Triggers.click(container.firstChild.firstChild);

        expect(instance.state).toEqual({
            handled: "true",
            "handled-bubble": "true",
            value: "changed"
        });

        expect(container.firstChild.firstChild.innerHTML).toBe("true");
        expect(logs).toHaveSameItemsAs([
            "handle-click start",
            "handle-change start",
            "handle-change end",
            "handle-click end",
            "handle-bubble start",
            "handle-bubble end",
            "setState",
            "setState-change",
            "setState-bubble",
            "componentWillUpdate",
            "componentDidUpdate",
            "setState-cb",
            "setState-change-cb",
            "forceUpdate-change-cb",
            "setState-bubble-cb"
        ]);

    });

});
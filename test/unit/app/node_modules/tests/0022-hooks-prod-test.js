/* eslint-env node, jasmine */
/* eslint-disable no-undefined, class-methods-use-this, no-return-assign, no-magic-numbers */

describe("hooks-prod", () => {
    "use strict";

    if (document.documentMode === 9) {
        // Poor MDL support on IE9
        return;
    }

    var vrdom;
    var hooks;
    var MDLComponent, MDLMiddleware;

    beforeAll((done) => {
        window.require.undef("vrdom");

        require(["vrdom", "material-design-lite"], function(_vrdom, componentHandler) {
            vrdom = arguments[0];
            hooks = vrdom.hooks;

            var MDL_CLASSES = [
                "mdl-js-button",
                "mdl-js-checkbox",
                "mdl-js-icon-toggle",
                "mdl-js-menu",
                "mdl-js-progress",
                "mdl-js-radio",
                "mdl-js-slider",
                "mdl-js-snackbar",
                "mdl-js-spinner",
                "mdl-js-switch",
                "mdl-js-tabs",
                "mdl-js-textfield",
                "mdl-tooltip",
                "mdl-js-layout",
                "mdl-js-data-table",
                "mdl-js-ripple-effect"
            ];

            var MDL_CLASSES_REG = new RegExp("(?:^|\\s)(?:" + MDL_CLASSES.join("|") + ")(?:\\s|$)");

            MDLComponent = class extends vrdom.Component {
                componentDidMount() {
                    this.el = vrdom.findDOMNode(this);
                    this.upgradeElements(this.el);
                }

                componentWillUnmount() {
                    this.downgradeElements(this.el);
                    delete this.el;
                }

                upgradeElements(el) {
                    if (MDL_CLASSES_REG.test(el.className) && el.getAttribute("data-upgraded") === null) {
                        componentHandler.upgradeElement(el);
                    }

                    var children = el.children;
                    for (var i = 0, len = children.length, child; i < len; i++) {
                        child = children[i];
                        this.upgradeElements(child);
                    }
                }

                downgradeElements(el) {
                    var children = el.children;
                    for (var i = 0, len = children.length, child; i < len; i++) {
                        child = children[i];
                        this.downgradeElements(child);
                    }

                    if (MDL_CLASSES_REG.test(el.className) && el.getAttribute("data-upgraded") !== null) {
                        componentHandler.downgradeElements([el]);
                    }
                }

                render() {
                    var tagName = this.props.tagName || "span";
                    var args = [tagName, this.props.config];

                    // add children
                    var children = this.props.children;
                    if (Array.isArray(children)) {
                        args.push.apply(args, children);
                    } else if (children != null) {
                        args.push(children);
                    }

                    // create the node,
                    // upgrade on mount,
                    // downgrage on unmount
                    return vrdom.createElement.apply(vrdom, args);
                }
            };

            MDLMiddleware = function MDLMiddleware(args) {
                var type = args[0];
                var config = args[1];

                if (config && !config.mdlIgnore && "string" === typeof type && MDL_CLASSES_REG.test(config.className)) {
                    args[0] = MDLComponent; // replace element type with MDLComponent

                    args[1] = {
                        key: config.key, // preserve key
                        ref: config.ref, // preserve ref
                        tagName: type,
                        config: vrdom.functions.assign({}, config) // clone because we will modify config
                    };

                    // ignore MDLMiddleware when creating element in MDLComponent
                    // and thus avoiding a stack overflow
                    args[1].config.mdlIgnore = true;

                    delete args[1].config.key; // key has been used
                    delete args[1].config.ref; // ref has been used
                }

                return args;
            };

            done();
        });
    });

    afterAll(() => {
        vrdom.reset();
    });

    it("should add/remove beforeCreateElement hook for all", ()=> {
        var button;
        function MDLElement() {
            /* Accent-colored raised button with ripple */
            return (
                <button ref={ (el) => button = el } className="mdl-button mdl-js-button mdl-button--raised mdl-js-ripple-effect mdl-button--accent">
                    Button
                </button>
            );
        }

        var container = document.createElement("div");

        expect(hooks.hasHooks("beforeCreateElement")).toBe(false);
        hooks.appendHook("beforeCreateElement", MDLMiddleware);
        expect(hooks.hasHooks("beforeCreateElement")).toBe(true);
        vrdom.render(<MDLElement />, container);
        expect(button).toEqual(jasmine.any(MDLComponent));
        expect(button.el.getAttribute("data-upgraded")).toBe(",MaterialButton,MaterialRipple");
        vrdom.unmountComponentAtNode(container);

        hooks.removeHook("beforeCreateElement", MDLMiddleware);
        vrdom.render(<MDLElement />, container);
        expect(button.getAttribute("data-upgraded")).toBe(null);
        vrdom.unmountComponentAtNode(container);

        hooks.prependHook("beforeCreateElement", MDLMiddleware);
        vrdom.render(<MDLElement />, container);
        expect(button).toEqual(jasmine.any(MDLComponent));
        expect(button.el.getAttribute("data-upgraded")).toBe(",MaterialButton,MaterialRipple");
        vrdom.unmountComponentAtNode(container);

        hooks.removeHook("beforeCreateElement", Function.prototype);
        hooks.removeHook("beforeCreateElement", MDLMiddleware);
        expect(hooks.hasHooks("beforeCreateElement")).toBe(false);
    });

    it("should add/remove beforeCreateElement hook for specific", ()=> {
        var label, button;
        var count = 0;

        function MDLElement() {
            return (
                <form>
                    <label ref={ (el) => label = el } className="mdl-checkbox mdl-js-checkbox mdl-js-ripple-effect" htmlFor="checkbox-1">
                        <input type="checkbox" id="checkbox-1" className="mdl-checkbox__input" checked onChange={ Function.prototype } />
                        <span className="mdl-checkbox__label">Checkbox</span>
                    </label>

                    {/* Accent-colored raised button with ripple */}
                    <button ref={ (el) => button = el } className="mdl-button mdl-js-button mdl-button--raised mdl-js-ripple-effect mdl-button--accent">
                        Button
                    </button>
                </form>
            );
        }

        function countElement(args) {
            count++;
            return args;
        }

        expect(hooks.hasHooks("beforeCreateElement", "button")).toBe(false);
        hooks.appendHook("beforeCreateElement", "button", MDLMiddleware);
        expect(hooks.hasHooks("beforeCreateElement", "button")).toBe(true);
        expect(hooks.hasHooks("beforeCreateElement", 1)).toBe(false);

        var container = document.createElement("div");
        vrdom.render(<MDLElement />, container);

        expect(label).toEqual(jasmine.any(HTMLElement));
        expect(button).toEqual(jasmine.any(MDLComponent));

        expect(button.el.getAttribute("data-upgraded")).toBe(",MaterialButton,MaterialRipple");
        vrdom.unmountComponentAtNode(container);

        expect(label).toBe(null);
        expect(button).toBe(null);

        hooks.removeHook("beforeCreateElement", "button", MDLMiddleware);
        expect(hooks.hasHooks("beforeCreateElement", "button")).toBe(false);

        vrdom.render(<MDLElement />, container);
        expect(label).toEqual(jasmine.any(HTMLElement));
        expect(button).toEqual(jasmine.any(HTMLElement));
        expect(button.getAttribute("data-upgraded")).toBe(null);
        vrdom.unmountComponentAtNode(container);

        hooks.appendHook("beforeCreateElement", "input span", MDLMiddleware);
        hooks.prependHook("beforeCreateElement", "label button", MDLMiddleware);
        hooks.prependHook("beforeCreateElement", "input", countElement);
        hooks.appendHook("beforeCreateElement", "span", countElement);

        expect(hooks.hasHooks("beforeCreateElement", "label input span button")).toBe(true);

        count = 0;
        vrdom.render(<MDLElement />, container);
        expect(label).toEqual(jasmine.any(MDLComponent));
        expect(button).toEqual(jasmine.any(MDLComponent));
        expect(count).toBe(2); // input + span

        expect(label.el.getAttribute("data-upgraded")).toBe(",MaterialCheckbox,MaterialRipple");
        expect(button.el.getAttribute("data-upgraded")).toBe(",MaterialButton,MaterialRipple");
        vrdom.unmountComponentAtNode(container);

        hooks.removeHook("beforeCreateElement", "label input span button", MDLMiddleware);

        count = 0;
        vrdom.render(<MDLElement />, container);
        expect(label).toEqual(jasmine.any(HTMLElement));
        expect(button).toEqual(jasmine.any(HTMLElement));
        expect(count).toBe(2);//  input + span

        expect(label.getAttribute("data-upgraded")).toBe(null);
        expect(button.getAttribute("data-upgraded")).toBe(null);
        vrdom.unmountComponentAtNode(container);

        hooks.removeHook("beforeCreateElement", "label input span button", Function.prototype);
        hooks.removeHook("beforeCreateElement", "label input span button", countElement);

        expect(hooks.hasHooks("beforeCreateElement", "label input span button")).toBe(false);
    });

    it("should add/remove component{DidMount,DidUpdate,WillUnmount} hook for all", ()=> {
        var logs = [];

        function logger(msg, vnode) {
            logs.push([msg, {
                type: vnode.type,
                text: vnode.text,
                isVNode: vnode.isVNode,
                isVText: vnode.isVText,
                isWidget: vnode.isWidget,
            }]);
        }

        class Component extends vrdom.Component {
            render() {
                return <div data-text={ this.props.text }>{ [this.props.text] }</div>;
            }
        }

        var componentDidMountLogger = logger.bind(null, "componentDidMount");
        var componentDidUpdateLogger = logger.bind(null, "componentDidUpdate");
        var componentWillUnmountLogger = logger.bind(null, "componentWillUnmount");

        expect(hooks.hasHooks("componentDidMount")).toBe(false);
        hooks.appendHook("componentDidMount", componentDidMountLogger);
        expect(hooks.hasHooks("componentDidMount")).toBe(true);

        expect(hooks.hasHooks("componentDidUpdate")).toBe(false);
        hooks.appendHook("componentDidUpdate", componentDidUpdateLogger);
        expect(hooks.hasHooks("componentDidUpdate")).toBe(true);

        expect(hooks.hasHooks("componentWillUnmount")).toBe(false);
        hooks.appendHook("componentWillUnmount", componentWillUnmountLogger);
        expect(hooks.hasHooks("componentWillUnmount")).toBe(true);

        var container = document.createElement("div");

        vrdom.render(<Component text="text" />, container);
        expect(logs).toEqual([
            ["componentDidMount", {
                type: "VirtualText",
                text: "text",
                isVNode: undefined,
                isVText: true,
                isWidget: undefined
            }],
            ["componentDidMount", {
                type: "div",
                text: undefined,
                isVNode: true,
                isVText: undefined,
                isWidget: undefined
            }],
            ["componentDidMount", {
                type: Component,
                text: undefined,
                isVNode: undefined,
                isVText: undefined,
                isWidget: true
            }]
        ]);
        logs.length = 0;

        vrdom.render(<Component text="updated text" />, container);
        expect(logs).toEqual([
            ["componentDidUpdate", {
                type: "VirtualText",
                text: "updated text",
                isVNode: undefined,
                isVText: true,
                isWidget: undefined
            }],
            ["componentDidUpdate", {
                type: "div",
                text: undefined,
                isVNode: true,
                isVText: undefined,
                isWidget: undefined
            }],
            ["componentDidUpdate", {
                type: Component,
                text: undefined,
                isVNode: undefined,
                isVText: undefined,
                isWidget: true
            }]
        ]);
        logs.length = 0;

        vrdom.unmountComponentAtNode(container);
        expect(logs).toEqual([
            ["componentWillUnmount", {
                type: Component,
                text: undefined,
                isVNode: undefined,
                isVText: undefined,
                isWidget: true
            }],
            ["componentWillUnmount", {
                type: "div",
                text: undefined,
                isVNode: true,
                isVText: undefined,
                isWidget: undefined
            }],
            ["componentWillUnmount", {
                type: "VirtualText",
                text: "updated text",
                isVNode: undefined,
                isVText: true,
                isWidget: undefined
            }]
        ]);
        logs.length = 0;

        hooks.removeHook("componentDidMount", componentDidMountLogger);
        hooks.removeHook("componentDidUpdate", componentDidUpdateLogger);
        hooks.removeHook("componentWillUnmount", componentWillUnmountLogger);

        expect(hooks.hasHooks("componentDidMount")).toBe(false);
        expect(hooks.hasHooks("componentDidUpdate")).toBe(false);
        expect(hooks.hasHooks("componentWillUnmount")).toBe(false);

        vrdom.render(<div>text</div>, container);
        vrdom.render(<div id="updated">text</div>, container);
        vrdom.unmountComponentAtNode(container);
        expect(logs).toEqual([]);
    });

});
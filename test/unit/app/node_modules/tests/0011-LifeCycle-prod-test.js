/* eslint-env node, jasmine */
/* eslint-disable no-undefined, class-methods-use-this */

describe("LifeCycle-prod", () => {
    "use strict";

    var vrdom;

    var hasProp = Object.prototype.hasOwnProperty;
    var slice = Array.prototype.slice;
    var LoggerComponent;
    var _;

    function getFunctionName(fn) {
        if ("name" in fn) {
            return fn.name;
        }

        if (fn === Object) {
            return "Object";
        }

        var match = fn.toString().match(/^function\s*([^\s(]+)/);
        return match && match[1];
    }

    function logger(msg) {
        return function() {
            var args = slice.call(arguments);
            var arg;
            for (var i = 0, len = args.length; i < len; i++) {
                arg = args[i];
                if (Array.isArray(arg) || arg && "object" === typeof arg && arg.constructor === Object) {
                    args[i] = _.clone(arg);
                }
            }

            // eslint-disable-next-line no-invalid-this
            this.props.logs.push([this.constructor.displayName || getFunctionName(this.constructor), msg, args]);
            return true;
        };
    }

    function isObject(obj) {
        return obj && ("object" === typeof obj || "function" === typeof obj);
    }

    function defaults(dst, src) {
        var prop;
        if (!isObject(dst) || !isObject(src)) {
            return dst;
        }
        for (prop in src) {
            if (!hasProp.call(src, prop)) {
                continue;
            }
            if (!hasProp.call(dst, prop)) {
                dst[prop] = src[prop];
            }
        }
        return dst;
    }

    beforeAll((done) => {
        require.undef("vrdom");

        require(["vrdom", "lodash"], function() {
            vrdom = arguments[0];
            _ = arguments[1];

            var Component = vrdom.Component;

            LoggerComponent = class extends Component {
                constructor(props) {
                    super(props);
                    logger("constructor").call(this);
                    this.setRef = logger("setRef").bind(this);
                }

                render() {
                    logger("render").call(this);
                    return <div ref={ this.setRef } />;
                }

                setState(state, callback) {
                    var args = slice.call(arguments);

                    if ("function" !== typeof callback) {
                        args[1] = logger("setState-cb").bind(this, state);
                    }

                    Component.prototype.setState.apply(this, args);
                }
            };

            LoggerComponent.prototype.componentWillMount = logger("componentWillMount");
            LoggerComponent.prototype.componentDidMount = logger("componentDidMount");
            LoggerComponent.prototype.componentWillReceiveProps = logger("componentWillReceiveProps");
            LoggerComponent.prototype.shouldComponentUpdate = logger("shouldComponentUpdate");
            LoggerComponent.prototype.componentWillUpdate = logger("componentWillUpdate");
            LoggerComponent.prototype.componentDidUpdate = logger("componentDidUpdate");
            LoggerComponent.prototype.componentWillUnmount = logger("componentWillUnmount");

            done();
        });
    });

    afterAll(() => {
        vrdom.reset();
    });

    it("should have null state without getInitialState", () => {
        var calls = 0;
        class Component extends vrdom.Component {
            componentWillMount() {
                calls++;
                expect(this.state).toBe(null);
            }

            render() {
                return <div />;
            }
        }

        var container = document.createElement("div");
        var instance = vrdom.render(<Component />, container);
        expect(calls).toBe(1);
        expect(instance.state).toBe(null);
    });

    it("should validate inital render cycle", () => {
        var logs = [];

        var container = document.createElement("div");
        vrdom.render(<LoggerComponent logs={ logs } />, container);
        vrdom.unmountComponentAtNode(container);

        expect(logs).toEqual([
            // Initialization start
            // ================================
            ["LoggerComponent", "constructor", []],
            ["LoggerComponent", "componentWillMount", []],
            ["LoggerComponent", "render", []],
            ["LoggerComponent", "setRef", [jasmine.any(HTMLElement)]], // setRef should be called just after rendered element is mounted
            ["LoggerComponent", "componentDidMount", []],
            // ================================
            // Initialization end

            // Destruction start
            // ================================
            // Before unmounting, any tasks done in componenentDidMount/componentDidUpdate
            // should be undone first.
            // Therefore, componentWillUnmount is called first.
            ["LoggerComponent", "componentWillUnmount", []],

            // Then children should be destroyed.
            // To prevent ref owner from using child after destruction,
            // ref should be set to null before starting child destruction.
            ["LoggerComponent", "setRef", [null]],
            // ================================
            // Destruction end

        ]);
    });

    it("should treat plain object instance as Component instance", () => {
        var logs = [];

        function FakeComponent(props) {
            var obj = defaults({
                render: LoggerComponent.prototype.render,
                setState: LoggerComponent.prototype.setState,
                props: props
            }, LoggerComponent.prototype);

            logger("constructor").call(obj);

            obj.setRef = logger("setRef").bind(obj);

            return obj;
        }

        var container = document.createElement("div");
        vrdom.render(<FakeComponent logs={ logs } />, container);
        vrdom.unmountComponentAtNode(container);

        expect(logs).toEqual([
            // Initialization start
            // ================================
            ["Object", "constructor", []],
            ["Object", "componentWillMount", []],
            ["Object", "render", []],
            ["Object", "setRef", [jasmine.any(HTMLElement)]], // setRef should be called just after rendered element is mounted
            ["Object", "componentDidMount", []],
            // ================================
            // Initialization end

            // Destruction start
            // ================================
            // Before unmounting, any tasks done in componenentDidMount/componentDidUpdate
            // should be undone first.
            // Therefore, componentWillUnmount is called first.
            ["Object", "componentWillUnmount", []],

            // Then children should be destroyed.
            // To prevent ref owner from using child after destruction,
            // ref should be set to null before starting child destruction.
            ["Object", "setRef", [null]],
            // ================================
            // Destruction end

        ]);
    });

    it("should validate inital update cycle", () => {
        var logs = [];

        var container = document.createElement("div");
        vrdom.render(<LoggerComponent logs={ logs } />, container);
        vrdom.render(<LoggerComponent logs={ logs } />, container);
        vrdom.unmountComponentAtNode(container);

        var expected = [
            // Initialization start
            // ================================
            ["LoggerComponent", "constructor", []],
            ["LoggerComponent", "componentWillMount", []],
            ["LoggerComponent", "render", []],
            ["LoggerComponent", "setRef", [jasmine.any(HTMLElement)]], // setRef should be called just after rendered element is mounted
            ["LoggerComponent", "componentDidMount", []],
            // ================================
            // Initialization end

            // Update start
            // ================================
            ["LoggerComponent", "componentWillReceiveProps", [{ logs }, {}]],
            ["LoggerComponent", "shouldComponentUpdate", [{ logs }, null, {}]],
            ["LoggerComponent", "componentWillUpdate", [{ logs }, null, {}]],
            ["LoggerComponent", "render", []],
            ["LoggerComponent", "componentDidUpdate", [{ logs }, null, {}]],
            // ================================
            // Update end

            // Destruction start
            // ================================
            // Before unmounting, any tasks done in componenentDidMount/componentDidUpdate
            // should be undone first.
            // Therefore, componentWillUnmount is called first.
            ["LoggerComponent", "componentWillUnmount", []],

            // Then children should be destroyed.
            // To prevent ref owner from using child after destruction,
            // ref should be set to null before starting child destruction.
            ["LoggerComponent", "setRef", [null]],
            // ================================
            // Destruction end
        ];

        // for better failure message
        expect(logs.length).toBe(expected.length);
        for (let i = 0, len = expected.length; i < len; i++) {
            expect(logs[i]).toHaveSameItemsAs(expected[i]);
        }
    });

    it("should handle setState in componentDidMount", () => {
        var logs = [];

        class Child extends LoggerComponent {
        }

        class Parent extends LoggerComponent {
            constructor(props) {
                super(props);
                this.state = {child: false};
            }

            render() {
                logger("render").call(this);

                if (this.state.child) {
                    return <Child logs={ this.props.logs } ref={ this.setRef } />;
                }

                return <div ref={ this.setRef } />;
            }

            componentDidMount() {
                LoggerComponent.prototype.componentDidMount.apply(this, arguments);
                this.setState({child: true});
            }
        }

        var container = document.createElement("div");

        vrdom.render(<Parent logs={ logs } />, container);
        vrdom.unmountComponentAtNode(container);

        var expected = [
            // Parent Initialization start
            // ================================
            ["Parent", "constructor", []],
            ["Parent", "componentWillMount", []],
            ["Parent", "render", []],
            ["Parent", "setRef", [jasmine.any(HTMLElement)]], // setRef should be called just after rendered element is mounted
            ["Parent", "componentDidMount", []],
            // ================================
            // Parent Initialization end

            // Parent setState start
            // ================================
            ["Parent", "shouldComponentUpdate", [{ logs }, {child: true}, {}]],
            ["Parent", "componentWillUpdate", [{ logs }, {child: true}, {}]],
            ["Parent", "render", []],
            ["Parent", "setRef", [null]], // previous child will be destroyed because of new child returned by render

            // Child Initialization start
            // ================================
            ["Child", "constructor", []],
            ["Child", "componentWillMount", []],
            ["Child", "render", []],
            ["Child", "setRef", [jasmine.any(HTMLElement)]],
            ["Child", "componentDidMount", []],
            ["Parent", "setRef", [jasmine.any(Child)]], // new child has been created
            // ================================
            // Child Initialization end

            ["Parent", "componentDidUpdate", [{ logs }, {child: false}, {}]],
            ["Parent", "setState-cb", [{child: true}]],
            // ================================
            // Parent setState end

            // Parent Destruction start
            // ================================
            // Before unmounting, any tasks done in componenentDidMount/componentDidUpdate
            // should be undone first.
            // Therefore, componentWillUnmount is called first.
            ["Parent", "componentWillUnmount", []],

            // Child Destruction start
            // ================================
            // Then children should be destroyed.
            // To prevent ref owner from using child after destruction,
            // ref should be set to null before starting child destruction.
            ["Parent", "setRef", [null]],

            // Before unmounting, any tasks done in componenentDidMount/componentDidUpdate
            // should be undone first.
            // Therefore, componentWillUnmount is called first.
            ["Child", "componentWillUnmount", []],

            // Then children should be destroyed.
            // To prevent ref owner from using child after destruction,
            // ref should be set to null before starting child destruction.
            ["Child", "setRef", [null]],
            // ================================
            // Child Destruction end

            // ================================
            // Parent Destruction end
        ];

        // for better failure message
        expect(logs.length).toBe(expected.length);
        for (let i = 0, len = expected.length; i < len; i++) {
            expect(logs[i]).toHaveSameItemsAs(expected[i]);
        }
    });

    it("should determine isMounted for createClass", () => {
        spyOn(console, "error");

        var Component = vrdom.createClass({
            componentWillMount() {
                expect(this.isMounted()).toBe(false);
            },

            render() {
                expect(this.isMounted()).toBe(false);
                return <div/>;
            },

            componentDidMount() {
                expect(this.isMounted()).toBe(true);
            }
        });

        var container = document.createElement("container");
        var instance = vrdom.render(<Component />, container);
        expect(instance.isMounted()).toBe(true);

        expect(console.error.calls.count()).toBe(0);
    });

    it("should determine isMounted for createClass that renders null", () => {
        spyOn(console, "error");

        var Component = vrdom.createClass({
            componentWillMount() {
                expect(this.isMounted()).toBe(false);
            },

            render() {
                expect(this.isMounted()).toBe(false);
                return null;
            },

            componentDidMount() {
                expect(this.isMounted()).toBe(true);
            }
        });

        var container = document.createElement("container");
        var instance = vrdom.render(<Component />, container);
        expect(instance.isMounted()).toBe(true);

        expect(console.error.calls.count()).toBe(0);
    });

    it("should determine isMounted on unmounted", () => {
        var Component = vrdom.createClass({
            render: function() {
                return <div/>;
            }
        });

        var container = document.createElement("div");
        var instance = vrdom.render(<Component />, container);
        vrdom.unmountComponentAtNode(container);
        expect(instance.isMounted()).toBe(false);
    });

    it("should create new instances at each remount", () => {
        // keep reference to container to ensure that instance data is cleared after unmount
        var container = document.createElement("div");

        class Component extends vrdom.Component {
            render() {
                return <div />;
            }
        }

        // keep reference to element to ensure that no instance data is stored in it
        var element = <Component />;

        var instance0 = vrdom.render(element, container);

        // should clean everything
        vrdom.unmountComponentAtNode(container);

        // should not use previous data
        var instance1 = vrdom.render(element, container);
        expect(instance0).not.toBe(instance1);

        vrdom.unmountComponentAtNode(container);
    });

    it("should allow vrdom.render in componentDidMount/componentDidUpdate and vrdom.unmountComponentAtNode in componentWillUnmount", () => {
        class SubComponent extends LoggerComponent {
            render() {
                logger("render").call(this);

                return (
                    <div ref={ this.setRef }>
                        <div>{ this.props.children }</div>
                        <div ref="container" />
                    </div>
                );
            }

            componentDidMount() {
                LoggerComponent.prototype.componentDidMount.apply(this, arguments);
                this.updateContent();
            }

            componentDidUpdate() {
                LoggerComponent.prototype.componentDidUpdate.apply(this, arguments);
                this.updateContent();
            }

            componentWillUnmount() {
                LoggerComponent.prototype.componentWillUnmount.apply(this, arguments);
                vrdom.unmountComponentAtNode(this.refs.container);
            }

            updateContent() {
                vrdom.render(this.props.content, this.refs.container);
            }
        }

        class ContentComponent extends LoggerComponent {
            render() {
                logger("render").call(this);
                return <div ref={ this.setRef }>{ this.props.children }</div>;
            }
        }

        class MainComponent extends LoggerComponent {
            render() {
                logger("render").call(this);

                var content = <ContentComponent ref={ this.setRef } logs={ this.props.logs }>{ this.props.content }</ContentComponent>;

                return (
                    <SubComponent logs={ this.props.logs } ref={ this.setRef } content={ content }>
                        { this.props.children }
                    </SubComponent>
                );
            }
        }

        var logs = [];
        var container = document.createElement("div");

        vrdom.render(<MainComponent logs={ logs } content="CONTENT HERE">HEADER HERE</MainComponent>, container);
        expectParts("HEADER HERE", "CONTENT HERE");
        expectLogs(logs, [
            // MainComponent Initialization start
            // ================================
            ["MainComponent", "constructor", []],
            ["MainComponent", "componentWillMount", []],
            ["MainComponent", "render", []],

            // SubComponent initialization start
            // ================================
            ["SubComponent", "constructor", []],
            ["SubComponent", "componentWillMount", []],
            ["SubComponent", "render", []],
            ["SubComponent", "setRef", [jasmine.any(HTMLElement)]],
            ["SubComponent", "componentDidMount", []],

            // ContentComponent initialization
            // ================================
            ["ContentComponent", "constructor", []],
            ["ContentComponent", "componentWillMount", []],
            ["ContentComponent", "render", []],
            ["ContentComponent", "setRef", [jasmine.any(HTMLElement)]],
            ["ContentComponent", "componentDidMount", []],
            ["MainComponent", "setRef", [jasmine.any(ContentComponent)]], // setRef should be called just after rendered element is mounted
            // ================================
            // ContentComponent Initialization end

            ["MainComponent", "setRef", [jasmine.any(SubComponent)]], // setRef should be called just after rendered element is mounted
            // ================================
            // SubComponent Initialization end

            ["MainComponent", "componentDidMount", []],
            // ================================
            // MainComponent Initialization end
        ]);

        vrdom.render(<MainComponent logs={ logs } content="ANOTHER CONTENT HERE">HEADER HERE</MainComponent>, container);
        expectParts("HEADER HERE", "ANOTHER CONTENT HERE");
        expectLogs(logs, [
            // MainComponent Update start
            // ================================
            ["MainComponent", "componentWillReceiveProps", [{ logs, content: "ANOTHER CONTENT HERE", children: "HEADER HERE" }, {}]],
            ["MainComponent", "shouldComponentUpdate", [{ logs, content: "ANOTHER CONTENT HERE", children: "HEADER HERE" }, null, {}]],
            ["MainComponent", "componentWillUpdate", [{ logs, content: "ANOTHER CONTENT HERE", children: "HEADER HERE" }, null, {}]],
            ["MainComponent", "render", []],

            // SubComponent Update start
            // ================================
            ["SubComponent", "componentWillReceiveProps", [{ logs, children: "HEADER HERE", content: jasmine.any(Object) }, {}]],
            ["SubComponent", "shouldComponentUpdate", [{ logs, children: "HEADER HERE", content: jasmine.any(Object) }, null, {}]],
            ["SubComponent", "componentWillUpdate", [{ logs, children: "HEADER HERE", content: jasmine.any(Object) }, null, {}]],
            ["SubComponent", "render", []],
            ["SubComponent", "componentDidUpdate", [{ logs, children: "HEADER HERE", content: jasmine.any(Object) }, null, {}]],

            // ContentComponent Update start
            // ================================
            ["ContentComponent", "componentWillReceiveProps", [{ logs, children: "ANOTHER CONTENT HERE" }, {}]],
            ["ContentComponent", "shouldComponentUpdate", [{ logs, children: "ANOTHER CONTENT HERE" }, null, {}]],
            ["ContentComponent", "componentWillUpdate", [{ logs, children: "ANOTHER CONTENT HERE" }, null, {}]],
            ["ContentComponent", "render", []],
            ["ContentComponent", "componentDidUpdate", [{ logs, children: "CONTENT HERE" }, null, {}]],
            // ================================
            // ContentComponent Update end

            // ================================
            // SubComponent Update end

            ["MainComponent", "componentDidUpdate", [{ logs, content: "CONTENT HERE", children: "HEADER HERE" }, null, {}]],
            // ================================
            // MainComponent Update end
        ]);

        vrdom.render(<MainComponent logs={ logs } content="ANOTHER CONTENT HERE">ANOTHER HEADER HERE</MainComponent>, container);
        expectParts("ANOTHER HEADER HERE", "ANOTHER CONTENT HERE");
        expectLogs(logs, [
            // MainComponent Update start
            // ================================
            ["MainComponent", "componentWillReceiveProps", [{ logs, content: "ANOTHER CONTENT HERE", children: "ANOTHER HEADER HERE" }, {}]],
            ["MainComponent", "shouldComponentUpdate", [{ logs, content: "ANOTHER CONTENT HERE", children: "ANOTHER HEADER HERE" }, null, {}]],
            ["MainComponent", "componentWillUpdate", [{ logs, content: "ANOTHER CONTENT HERE", children: "ANOTHER HEADER HERE" }, null, {}]],
            ["MainComponent", "render", []],

            // SubComponent Update start
            // ================================
            ["SubComponent", "componentWillReceiveProps", [{ logs, children: "ANOTHER HEADER HERE", content: jasmine.any(Object) }, {}]],
            ["SubComponent", "shouldComponentUpdate", [{ logs, children: "ANOTHER HEADER HERE", content: jasmine.any(Object) }, null, {}]],
            ["SubComponent", "componentWillUpdate", [{ logs, children: "ANOTHER HEADER HERE", content: jasmine.any(Object) }, null, {}]],
            ["SubComponent", "render", []],
            ["SubComponent", "componentDidUpdate", [{ logs, children: "HEADER HERE", content: jasmine.any(Object) }, null, {}]],

            // ContentComponent Update start
            // ================================
            ["ContentComponent", "componentWillReceiveProps", [{ logs, children: "ANOTHER CONTENT HERE" }, {}]],
            ["ContentComponent", "shouldComponentUpdate", [{ logs, children: "ANOTHER CONTENT HERE" }, null, {}]],
            ["ContentComponent", "componentWillUpdate", [{ logs, children: "ANOTHER CONTENT HERE" }, null, {}]],
            ["ContentComponent", "render", []],
            ["ContentComponent", "componentDidUpdate", [{ logs, children: "ANOTHER CONTENT HERE" }, null, {}]],
            // ================================
            // ContentComponent Update end

            // ================================
            // SubComponent Update end

            ["MainComponent", "componentDidUpdate", [{ logs, content: "ANOTHER CONTENT HERE", children: "HEADER HERE" }, null, {}]],
            // ================================
            // MainComponent Update end
        ]);

        vrdom.unmountComponentAtNode(container);
        expectLogs(logs, [
            // MainComponent Destruction start
            // ================================
            // Before unmounting, any tasks done in componenentDidMount/componentDidUpdate
            // should be undone first.
            // Therefore, componentWillUnmount is called first.
            ["MainComponent", "componentWillUnmount", []],

            // SubComponent Destruction start
            // ================================
            // Then children should be destroyed.
            // To prevent ref owner from using child after destruction,
            // ref should be set to null before starting child destruction.
            ["MainComponent", "setRef", [null]], // unref SubComponent

            // Before unmounting, any tasks done in componenentDidMount/componentDidUpdate
            // should be undone first.
            // Therefore, componentWillUnmount is called first.
            ["SubComponent", "componentWillUnmount", []],

            // ContentComponent Destruction start
            // ================================
            // Then children should be destroyed.
            // To prevent ref owner from using child after destruction,
            // ref should be set to null before starting child destruction.
            ["MainComponent", "setRef", [null]], // unref ContentComponent

            // Before unmounting, any tasks done in componenentDidMount/componentDidUpdate
            // should be undone first.
            // Therefore, componentWillUnmount is called first.
            ["ContentComponent", "componentWillUnmount", []],

            // Then children should be destroyed.
            // To prevent ref owner from using child after destruction,
            // ref should be set to null before starting child destruction.
            ["ContentComponent", "setRef", [null]], // unref div element
            // ================================
            // ContentComponent Destruction end

            // Then children should be destroyed.
            // To prevent ref owner from using child after destruction,
            // ref should be set to null before starting child destruction.
            ["SubComponent", "setRef", [null]], // unref div element
            // ================================
            // SubComponent Destruction end

            // ================================
            // MainComponent Destruction end
        ]);

        function expectParts(header, content) {
            expect(container.firstChild.tagName).toBe("DIV");
            expect(container.firstChild.childNodes.length).toBe(2);
            expect(container.firstChild.firstChild.tagName).toBe("DIV");
            expect(container.firstChild.firstChild.innerHTML).toBe(header);

            expect(container.firstChild.childNodes[1].tagName).toBe("DIV");
            expect(container.firstChild.childNodes[1].childNodes.length).toBe(1);
            expect(container.firstChild.childNodes[1].firstChild.tagName).toBe("DIV");
            expect(container.firstChild.childNodes[1].firstChild.innerHTML).toBe(content);
        }

        function expectLogs(logs, expected) {
            // for better failure message
            expect(logs.length).toBe(expected.length);
            for (let i = 0, len = expected.length; i < len; i++) {
                expect(logs[i]).toHaveSameItemsAs(expected[i]);
            }
            logs.length = 0;
        }
    });

    it("should not warn if `setState` in render", () => {
        spyOn(console, "error");

        var logs = [];

        class Component extends vrdom.Component {
            state = { count: 0 };

            render() {
                logs.push(this.state.count);

                if (this.state.count === 0) {
                    this.setState({ count: this.state.count + 1 });
                }

                return <div />;
            }
        }

        var container = document.createElement("div");
        var instance = vrdom.render(<Component />, container);

        expect(console.error.calls.count()).toBe(0);

        expect(instance.state.count).toBe(1);
        expect(logs).toEqual([0, 1]);

        vrdom.render(<Component value="value" />, container);
        expect(logs).toEqual([0, 1, 1]);
        expect(instance.state.count).toBe(1);

        vrdom.unmountComponentAtNode(container);
    });

    it("should not warn if `setState` on unmounted components", () => {
        spyOn(console, "error");

        class Component extends vrdom.Component {
            render() {
                return <div />;
            }
        }

        var container = document.createElement("div");

        var element = <Component />;
        var instance = vrdom.render(element, container);
        vrdom.unmountComponentAtNode(container);

        instance.setState({});
        expect(console.error.calls.count()).toBe(0);

        vrdom.unmountComponentAtNode(container);
    });

    it("should not warn if `forceUpdate` on unmounted components", () => {
        spyOn(console, "error");

        class Component extends vrdom.Component {
            render() {
                return <div />;
            }
        }

        var container = document.createElement("div");

        var element = <Component />;
        var instance = vrdom.render(element, container);
        vrdom.unmountComponentAtNode(container);

        instance.forceUpdate();
        expect(console.error.calls.count()).toBe(0);

        vrdom.unmountComponentAtNode(container);
    });

    it("should not warn if `replaceState` on unmounted components", () => {
        spyOn(console, "error");

        var Component = vrdom.createClass({
            render() {
                return <div />;
            }
        });

        var container = document.createElement("div");

        var element = <Component />;
        var instance = vrdom.render(element, container);
        vrdom.unmountComponentAtNode(container);

        instance.replaceState();
        expect(console.error.calls.count()).toBe(0);

        vrdom.unmountComponentAtNode(container);
    });

});
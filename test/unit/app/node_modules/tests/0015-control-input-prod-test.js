/* eslint-env node, jasmine */
/* eslint-disable no-undefined, class-methods-use-this */

describe("control-input-prod", () => {
    "use strict";

    var vrdom;
    var Triggers;
    var emptyFn = Function.prototype;

    beforeAll((done) => {
        window.require.undef("vrdom");

        require(["vrdom", "Triggers"], function() {
            vrdom = arguments[0];
            Triggers = arguments[1](vrdom);

            done();
        });
    });

    afterAll(() => {
        vrdom.reset();
    });

    it("should handle value in input type text", () => {
        var container = document.createElement("div");
        var domNode;

        ["string", 0, 1, true, false, { toString: () => "string" }].forEach(function(value) {
            domNode = vrdom.render(<input type="text" value={ value } readOnly={ true } />, container);
            expect(domNode.value).toBe(String(value));
            vrdom.unmountComponentAtNode(container);
        });
    });

    it("should handle defaultValue in input type text", () => {
        var container = document.createElement("div");
        var domNode;

        ["string", 0, 1, true, false, { toString: () => "string" }].forEach(function(defaultValue) {
            domNode = vrdom.render(<input type="text" defaultValue={ defaultValue } />, container);
            expect(domNode.value).toBe(String(defaultValue));
            expect(domNode.defaultValue).toBe(String(defaultValue));

            // updating default value should keep previous value
            domNode = vrdom.render(<input type="text" defaultValue={ defaultValue + "new" } />, container);
            expect(domNode.value).toBe(String(defaultValue));
            expect(domNode.defaultValue).toBe(String(defaultValue + "new"));

            // switching from uncontrolled to controlled is inconsistent
            domNode = vrdom.render(<input type="text" value={ defaultValue + "new" } onChange={ emptyFn } />, container);
            expect(domNode.value).toBe(String(defaultValue + "new"));

            domNode = vrdom.render(<input type="text" defaultValue={ defaultValue + "finally" } />, container);
            expect(domNode.value).toBe(String(defaultValue + "new"));
            expect(domNode.defaultValue).toBe(String(defaultValue + "finally"));

            vrdom.unmountComponentAtNode(container);
        });

        vrdom.reset();
    });

    it("should not change previously setted value when setting defaultValue", () => {
        var container = document.createElement("div");
        var domNode;

        domNode = vrdom.render(<input type="text" />, container);
        domNode.value = "value";
        vrdom.render(<input type="text" defaultValue="new value" />, container);
        expect(domNode.value).toBe("value");
        expect(domNode.defaultValue).toBe("new value");
        vrdom.unmountComponentAtNode(container);

        domNode = vrdom.render(<input type="text" value="value" readOnly={ true } />, container);
        expect(domNode.value).toBe("value");
        vrdom.render(<input type="text" defaultValue="new value" />, container);
        expect(domNode.value).toBe("value");
        expect(domNode.defaultValue).toBe("new value");
        vrdom.unmountComponentAtNode(container);

    });

    it("should not control input text without value", () => {
        var container = document.createElement("div");
        var domNode = vrdom.render(<input type="text" />, container);
        expect(domNode.value).toBe("");

        domNode.value = "uncontrolled";
        Triggers.change(domNode);
        expect(domNode.value).toBe("uncontrolled");

        domNode.value = "uncontrolled 2";
        Triggers.change(domNode);
        expect(domNode.value).toBe("uncontrolled 2");
    });

    it("should control input text with value as read only input", () => {
        var container = document.createElement("div");
        var domNode = vrdom.render(<input type="text" value="controlled" />, container);
        expect(domNode.value).toBe("controlled");

        domNode.value = "uncontrolled";
        Triggers.change(domNode);
        expect(domNode.value).toBe("controlled");

        domNode.value = "uncontrolled";
        Triggers.change(domNode);
        expect(domNode.value).toBe("controlled");

        vrdom.render(<input type="text" />, container);
        expect(domNode.value).toBe("controlled");

        domNode.value = "uncontrolled";
        Triggers.change(domNode);
        expect(domNode.value).toBe("uncontrolled");
    });

    it("should control input text", () => {
        class Component extends vrdom.Component {
            constructor(props, context) {
                super(props, context);
                this.handleChange = this.handleChange.bind(this);
                this.state = { value: "initial" };
            }

            handleChange(evt) {
                this.setState({ value: evt.target.value });
            }

            componentDidMount() {
                expect(vrdom.findDOMNode(this).value).toBe(this.state.value);
            }

            componentDidUpdate() {
                expect(vrdom.findDOMNode(this).value).toBe(this.state.value);
            }

            render() {
                return <input type="text" value={ this.state.value } onChange={ this.handleChange } />;
            }
        }

        var container = document.createElement("div");
        var instance = vrdom.render(<Component />, container);
        var domNode = vrdom.findDOMNode(instance);

        expect(domNode.value).toBe("initial");

        domNode.value = "changed";
        Triggers.change(domNode);
        expect(domNode.value).toBe("changed");

        domNode.value = "another try";
        Triggers.change(domNode);
        expect(domNode.value).toBe("another try");

        domNode.value = "finally";
        Triggers.change(domNode);
        expect(domNode.value).toBe("finally");

        instance.setState({ value: "try state value" });
        expect(domNode.value).toBe("try state value");

        instance.setState({ value: "another try state value" });
        expect(domNode.value).toBe("another try state value");

        instance.setState({ value: "finally try state value" });
        expect(domNode.value).toBe("finally try state value");
    });

    it("should not control input text after componentDidMount/componentDidUpdate", () => {
        class Component extends vrdom.Component {
            constructor(props, context) {
                super(props, context);
                this.handleChange = this.handleChange.bind(this);
                this.state = { value: "initial" };
            }

            handleChange(evt) {
                this.setState({ value: evt.target.value });
            }

            componentDidMount() {
                expect(vrdom.findDOMNode(this).value).toBe(this.state.value);
                vrdom.findDOMNode(this).value = "componentDidMount";
            }

            componentDidUpdate() {
                expect(vrdom.findDOMNode(this).value).toBe(this.state.value);
                vrdom.findDOMNode(this).value = "componentDidUpdate";
            }

            render() {
                return <input type="text" value={ this.state.value } onChange={ this.handleChange } />;
            }
        }

        var container = document.createElement("div");
        var instance = vrdom.render(<Component />, container);
        var domNode = vrdom.findDOMNode(instance);

        expect(domNode.value).toBe("componentDidMount");

        domNode.value = "changed";
        Triggers.change(domNode);
        expect(domNode.value).toBe("componentDidUpdate");

        domNode.value = "another try";
        Triggers.change(domNode);
        expect(domNode.value).toBe("componentDidUpdate");

        domNode.value = "finally";
        Triggers.change(domNode);
        expect(domNode.value).toBe("componentDidUpdate");

        instance.setState({ value: "try state value" });
        expect(domNode.value).toBe("componentDidUpdate");

        instance.setState({ value: "another try state value" });
        expect(domNode.value).toBe("componentDidUpdate");

        instance.setState({ value: "finally try state value" });
        expect(domNode.value).toBe("componentDidUpdate");
    });

    it("should control with valueLink", () => {
        var ValueLinkComponent = vrdom.createClass({
            requestChange: function(value) {
                this.setState({ text: value });
            },

            getValueLink: function() {
                this.valueLink.value = this.state.text;
                return this.valueLink;
            },

            componentWillMount: function() {
                this.valueLink = { requestChange: this.requestChange };
                this.setState({ text: "text" });
            },

            render: function() {
                return <input type="text" valueLink={ this.getValueLink() } />;
            }
        });

        var container = document.createElement("div");
        var instance = vrdom.render(<ValueLinkComponent />, container);
        var input = vrdom.findDOMNode(instance);

        expect(instance.state.text).toBe("text");
        expect(input.value).toBe(instance.state.text);

        input.value = "new text";
        Triggers.change(input);
        expect(instance.state.text).toBe("new text");
        expect(input.value).toBe(instance.state.text);

        instance.setState({ text: "text" });
        expect(instance.state.text).toBe("text");
        expect(input.value).toBe(instance.state.text);

        vrdom.unmountComponentAtNode(container);
    });

    it("should not control input checkbox without checked", () => {
        var container = document.createElement("div");

        // events are listen on global document,
        // therefore, we need to append container to body in order to catch them
        document.body.appendChild(container);

        var domNode = vrdom.render(<input type="checkbox" />, container);
        expect(domNode.checked).toBe(false);

        domNode.click();
        expect(domNode.checked).toBe(true);

        domNode.click();
        expect(domNode.checked).toBe(false);

        document.body.removeChild(container);
    });

    it("should control input checkbox with checked as read only input", () => {
        var container = document.createElement("div");

        // events are listen on global document,
        // therefore, we need to append container to body in order to catch them
        document.body.appendChild(container);

        var domNode = vrdom.render(<input type="checkbox" checked={ true } />, container);
        expect(domNode.checked).toBe(true);

        domNode.click();
        expect(domNode.checked).toBe(true);

        domNode.click();
        expect(domNode.checked).toBe(true);

        // switching to uncontrolled, should preserve existing checked
        vrdom.render(<input type="checkbox" />, container);
        expect(domNode.checked).toBe(true);

        domNode.click();
        expect(domNode.checked).toBe(false);

        domNode.click();
        expect(domNode.checked).toBe(true);

        document.body.removeChild(container);
    });

    it("should control input checkbox on change", () => {
        class Component extends vrdom.Component {
            constructor(props, context) {
                super(props, context);
                this.handleChange = this.handleChange.bind(this);
                this.state = { checked: false };
            }

            handleChange(evt) {
                this.setState({ checked: evt.target.checked });
            }

            componentDidMount() {
                expect(vrdom.findDOMNode(this).checked).toBe(this.state.checked);
            }

            componentDidUpdate() {
                expect(vrdom.findDOMNode(this).checked).toBe(this.state.checked);
            }

            render() {
                return <input type="checkbox" checked={ this.state.checked } onChange={ this.handleChange } />;
            }
        }

        var container = document.createElement("div");

        // events are listen on global document,
        // therefore, we need to append container to body in order to catch them
        document.body.appendChild(container);

        var instance = vrdom.render(<Component />, container);
        var domNode = vrdom.findDOMNode(instance);

        expect(domNode.checked).toBe(false);

        domNode.click();
        expect(domNode.checked).toBe(true);

        domNode.click();
        expect(domNode.checked).toBe(false);

        domNode.click();
        expect(domNode.checked).toBe(true);

        document.body.removeChild(container);
    });

    it("should not control input checkbox after componentDidMount/componentDidUpdate", () => {
        class Component extends vrdom.Component {
            constructor(props, context) {
                super(props, context);
                this.handleChange = this.handleChange.bind(this);
                this.state = { checked: false };
            }

            handleChange(evt) {
                this.setState({ checked: evt.target.checked });
            }

            componentDidMount() {
                expect(vrdom.findDOMNode(this).checked).toBe(this.state.checked);
                vrdom.findDOMNode(this).checked = false;
            }

            componentDidUpdate() {
                expect(vrdom.findDOMNode(this).checked).toBe(this.state.checked);
                vrdom.findDOMNode(this).checked = false;
            }

            render() {
                return <input type="checkbox" checked={ this.state.checked } onChange={ this.handleChange } />;
            }
        }

        var container = document.createElement("div");

        // events are listen on global document,
        // therefore, we need to append container to body in order to catch them
        document.body.appendChild(container);

        var instance = vrdom.render(<Component />, container);
        var domNode = vrdom.findDOMNode(instance);

        expect(domNode.checked).toBe(false);

        domNode.click();
        expect(domNode.checked).toBe(false);

        domNode.click();
        expect(domNode.checked).toBe(false);

        domNode.click();
        expect(domNode.checked).toBe(false);

        document.body.removeChild(container);
    });

    it("should control with checkedLink", () => {
        var CheckedLinkComponent = vrdom.createClass({
            requestChange: function(checked) {
                this.setState({ checked: checked });
            },

            getCheckedLink: function() {
                this.checkedLink.value = this.state.checked;
                return this.checkedLink;
            },

            componentWillMount: function() {
                this.checkedLink = { requestChange: this.requestChange };
                this.setState({ checked: true });
            },

            render: function() {
                return <input type="checkbox" checkedLink={ this.getCheckedLink() } />;
            }
        });

        var container = document.createElement("div");
        document.body.appendChild(container); // needed to catch input.click()
        var instance = vrdom.render(<CheckedLinkComponent />, container);
        var input = vrdom.findDOMNode(instance);

        expect(instance.state.checked).toBe(true);
        expect(input.checked).toBe(instance.state.checked);

        input.click();
        expect(instance.state.checked).toBe(false);
        expect(input.checked).toBe(instance.state.checked);

        instance.setState({ checked: true });
        expect(instance.state.checked).toBe(true);
        expect(input.checked).toBe(instance.state.checked);

        vrdom.unmountComponentAtNode(container);
        document.body.removeChild(container);
    });

    it("should not control radio buttons without checked", () => {
        class Component extends vrdom.Component {
            render() {
                return (
                    <div>
                        <input ref="0.0" type="radio" name="radio" />
                        <input ref="0.1" type="radio" name="radio" />

                        <form>
                            <input ref="1.0" type="radio" name="radio" />
                            <input ref="1.1" type="radio" name="radio" />
                        </form>

                        <form>
                            <input ref="2.0" type="radio" name="radio" />
                            <input ref="2.1" type="radio" name="radio" defaultChecked={ true } />
                        </form>
                    </div>
                );
            }
        }

        var container = document.createElement("div");

        // events are listen on global document,
        // therefore, we need to append container to body in order to catch them
        document.body.appendChild(container);

        var instance = vrdom.render(<Component />, container);
        var radios = instance.refs;

        expect(radios["0.0"].checked).toBe(false);
        expect(radios["0.1"].checked).toBe(false);
        expect(radios["1.0"].checked).toBe(false);
        expect(radios["1.1"].checked).toBe(false);
        expect(radios["2.0"].checked).toBe(false);
        expect(radios["2.1"].checked).toBe(true);

        radios["0.0"].click();

        expect(radios["0.0"].checked).toBe(true);
        expect(radios["0.1"].checked).toBe(false);
        expect(radios["1.0"].checked).toBe(false);
        expect(radios["1.1"].checked).toBe(false);
        expect(radios["2.0"].checked).toBe(false);
        expect(radios["2.1"].checked).toBe(true);

        radios["1.0"].click();

        expect(radios["0.0"].checked).toBe(true);
        expect(radios["0.1"].checked).toBe(false);
        expect(radios["1.0"].checked).toBe(true);
        expect(radios["1.1"].checked).toBe(false);
        expect(radios["2.0"].checked).toBe(false);
        expect(radios["2.1"].checked).toBe(true);

        radios["2.0"].click();

        expect(radios["0.0"].checked).toBe(true);
        expect(radios["0.1"].checked).toBe(false);
        expect(radios["1.0"].checked).toBe(true);
        expect(radios["1.1"].checked).toBe(false);
        expect(radios["2.0"].checked).toBe(true);
        expect(radios["2.1"].checked).toBe(false);

        vrdom.unmountComponentAtNode(container);

        document.body.removeChild(container);
    });

    it("should control radio buttons on change", () => {
        class Component extends vrdom.Component {
            render() {
                return (
                    <div>
                        <input ref="0.0" type="radio" name="radio" />
                        <input ref="0.1" type="radio" name="radio" checked={ true } onChange={ emptyFn } />

                        <form>
                            <input ref="1.0" type="radio" name="radio" />
                            <input ref="1.1" type="radio" name="radio" checked={ true } onChange={ emptyFn } />
                        </form>

                        <form>
                            <input ref="2.0" type="radio" name="radio" />
                            <input ref="2.1" type="radio" name="radio" defaultChecked={ true } />
                        </form>
                    </div>
                );
            }
        }

        var container = document.createElement("div");

        // events are listen on global document,
        // therefore, we need to append container to body in order to catch them
        document.body.appendChild(container);

        var instance = vrdom.render(<Component />, container);
        var radios = instance.refs;

        expect(radios["0.0"].checked).toBe(false);
        expect(radios["0.1"].checked).toBe(true);
        expect(radios["1.0"].checked).toBe(false);
        expect(radios["1.1"].checked).toBe(true);
        expect(radios["2.0"].checked).toBe(false);
        expect(radios["2.1"].checked).toBe(true);

        radios["0.0"].click();

        expect(radios["0.0"].checked).toBe(false);
        expect(radios["0.1"].checked).toBe(true);
        expect(radios["1.0"].checked).toBe(false);
        expect(radios["1.1"].checked).toBe(true);
        expect(radios["2.0"].checked).toBe(false);
        expect(radios["2.1"].checked).toBe(true);

        radios["1.0"].click();

        expect(radios["0.0"].checked).toBe(false);
        expect(radios["0.1"].checked).toBe(true);
        expect(radios["1.0"].checked).toBe(false);
        expect(radios["1.1"].checked).toBe(true);
        expect(radios["2.0"].checked).toBe(false);
        expect(radios["2.1"].checked).toBe(true);

        radios["2.0"].click();

        expect(radios["0.0"].checked).toBe(false);
        expect(radios["0.1"].checked).toBe(true);
        expect(radios["1.0"].checked).toBe(false);
        expect(radios["1.1"].checked).toBe(true);
        expect(radios["2.0"].checked).toBe(true);
        expect(radios["2.1"].checked).toBe(false);

        vrdom.unmountComponentAtNode(container);

        document.body.removeChild(container);
    });

    it("should control radio buttons after updates", () => {
        class Input extends vrdom.Component {
            render() {
                return <input { ...this.props } />;
            }

            componentDidMount() {
                this.node = vrdom.findDOMNode(this);
            }

            componentWillUpdate(nextProps, nextState) {
                if (nextState.checked) {
                    this.node.click();
                }
            }

            componentWillUnmount() {
                delete this.node;
            }
        }

        class Component extends vrdom.Component {
            render() {
                return (
                    <div>
                        <Input ref="0.0" type="radio" name="radio" />
                        <Input ref="0.1" type="radio" name="radio" checked={ true } onChange={ emptyFn } />

                        <form>
                            <Input ref="1.0" type="radio" name="radio" />
                            <Input ref="1.1" type="radio" name="radio" checked={ true } onChange={ emptyFn } />
                        </form>

                        <form>
                            <Input ref="2.0" type="radio" name="radio" />
                            <Input ref="2.1" type="radio" name="radio" defaultChecked={ true } />
                        </form>
                    </div>
                );
            }
        }

        var container = document.createElement("div");

        // events are listen on global document,
        // therefore, we need to append container to body in order to catch them
        document.body.appendChild(container);

        var instance = vrdom.render(<Component />, container);
        var radios = instance.refs;

        expect(radios["0.0"].node.checked).toBe(false);
        expect(radios["0.1"].node.checked).toBe(true);
        expect(radios["1.0"].node.checked).toBe(false);
        expect(radios["1.1"].node.checked).toBe(true);
        expect(radios["2.0"].node.checked).toBe(false);
        expect(radios["2.1"].node.checked).toBe(true);

        radios["0.0"].setState({checked: true});

        expect(radios["0.0"].node.checked).toBe(false);
        expect(radios["0.1"].node.checked).toBe(true);
        expect(radios["1.0"].node.checked).toBe(false);
        expect(radios["1.1"].node.checked).toBe(true);
        expect(radios["2.0"].node.checked).toBe(false);
        expect(radios["2.1"].node.checked).toBe(true);

        radios["1.0"].setState({checked: true});

        expect(radios["0.0"].node.checked).toBe(false);
        expect(radios["0.1"].node.checked).toBe(true);
        expect(radios["1.0"].node.checked).toBe(false);
        expect(radios["1.1"].node.checked).toBe(true);
        expect(radios["2.0"].node.checked).toBe(false);
        expect(radios["2.1"].node.checked).toBe(true);

        radios["2.0"].setState({checked: true});

        expect(radios["0.0"].node.checked).toBe(false);
        expect(radios["0.1"].node.checked).toBe(true);
        expect(radios["1.0"].node.checked).toBe(false);
        expect(radios["1.1"].node.checked).toBe(true);
        expect(radios["2.0"].node.checked).toBe(true);
        expect(radios["2.1"].node.checked).toBe(false);

        vrdom.unmountComponentAtNode(container);

        document.body.removeChild(container);
    });

    it("should handle input type change", () => {
        var container = document.createElement("div");
        var input = vrdom.render(<input type="text" value="text" readOnly="true"/>, container);

        vrdom.render(<input value="1" type="number" readOnly="true"/>, container);
        expect(input.value).toBe("1");

        vrdom.render(<input value="text" readOnly="true"/>, container);
        expect(input.value).toBe("text");

        vrdom.unmountComponentAtNode(container);
    });

    it("should not warn if value is null", () => {
        spyOn(console, "error");

        var container = document.createElement("div");
        vrdom.render(<input type="text" value={ null } onChange={ Function.prototype } />, container);

        expect(console.error.calls.count()).toBe(0);
    });

    it("should not warn if value change from uncontrolled to controlled", () => {
        spyOn(console, "error");

        var container = document.createElement("div");
        vrdom.render(<input type="text" defaultValue="defaultValue" />, container);
        vrdom.render(<input type="text" value="value" onChange={ Function.prototype } />, container);

        expect(console.error.calls.count()).toBe(0);
    });

    it("should not warn if value change from controlled to uncontrolled", () => {
        spyOn(console, "error");

        var container = document.createElement("div");
        vrdom.render(<input type="text" value="value" onChange={ Function.prototype } />, container);
        vrdom.render(<input type="text" defaultValue="defaultValue" />, container);

        expect(console.error.calls.count()).toBe(0);
    });

    it("should not warn if value and defaultValue", () => {
        spyOn(console, "error");

        var container = document.createElement("div");
        vrdom.render(<input value="value" defaultValue="defaultValue" onChange={ Function.prototype } />, container);

        expect(console.error.calls.count()).toBe(0);
    });

    it("should not warn if value is setted without readOnly nor onChange", () => {
        spyOn(console, "error");

        void(<input type="text" value="value" />); // eslint-disable-line no-void, no-extra-parens

        expect(console.error.calls.count()).toBe(0);

        void(<input type="text" value="value" readOnly={ true }/>); // eslint-disable-line no-void, no-extra-parens
        void(<input type="text" value="value" onChange={ emptyFn }/>); // eslint-disable-line no-void, no-extra-parens
        expect(console.error.calls.count()).toBe(0);
    });

    it("should not warn if checked is setted without readOnly nor onChange", () => {
        spyOn(console, "error");

        void(<input type="checkbox" checked={ true } />); // eslint-disable-line no-void, no-extra-parens

        expect(console.error.calls.count()).toBe(0);

        void(<input type="checkbox" checked={ true } readOnly={ true }/>); // eslint-disable-line no-void, no-extra-parens
        void(<input type="checkbox" checked={ true } onChange={ emptyFn }/>); // eslint-disable-line no-void, no-extra-parens
        expect(console.error.calls.count()).toBe(0);

    });

    it("should not warn if checked is null", () => {
        spyOn(console, "error");

        var container = document.createElement("div");
        vrdom.render(<input type="checkbox" checked={ null } onChange={ Function.prototype } />, container);

        expect(console.error.calls.count()).toBe(0);
    });

    it("should not warn if checked change from uncontrolled to controlled", () => {
        spyOn(console, "error");

        var container = document.createElement("div");
        vrdom.render(<input type="checkbox" defaultChecked />, container);
        vrdom.render(<input type="checkbox" checked onChange={ Function.prototype } />, container);

        expect(console.error.calls.count()).toBe(0);
    });

    it("should not warn if checked change from controlled to uncontrolled", () => {
        spyOn(console, "error");

        var container = document.createElement("div");
        vrdom.render(<input type="checkbox" checked onChange={ Function.prototype } />, container);
        vrdom.render(<input type="checkbox" defaultChecked />, container);

        expect(console.error.calls.count()).toBe(0);
    });

    it("should not warn if checked and defaultChecked", () => {
        spyOn(console, "error");

        var container = document.createElement("div");
        vrdom.render(<input type="checkbox" checked={ true } defaultChecked="defaultChecked" onChange={ Function.prototype } />, container);

        expect(console.error.calls.count()).toBe(0);
    });

    it("should not throw if both checkedLink and valueLink on input text", () => {
        var ValueLinkComponent = vrdom.createClass({
            render: function() {
                return <input type="text" checkedLink={{}} valueLink={{}} />;
            }
        });

        expect(() => {
            vrdom.render(<ValueLinkComponent />, document.createElement("div"));
        }).not.toThrow();
    });

    it("should not throw if both checkedLink and valueLink on input checkbox", () => {
        var ValueLinkComponent = vrdom.createClass({
            render: function() {
                return <input type="checkbox" checkedLink={{}} valueLink={{}} />;
            }
        });

        expect(() => {
            vrdom.render(<ValueLinkComponent />, document.createElement("div"));
        }).not.toThrow();
    });

    it("should not throw if both onChange and valueLink on input text", () => {
        var ValueLinkComponent = vrdom.createClass({
            render: function() {
                return <input type="text" onChange={ Function.prototype } valueLink={{}} />;
            }
        });

        expect(() => {
            vrdom.render(<ValueLinkComponent />, document.createElement("div"));
        }).not.toThrow();
    });

    it("should not throw if both onChange and valueLink on input checkbox", () => {
        var ValueLinkComponent = vrdom.createClass({
            render: function() {
                return <input type="checkbox" onChange={ Function.prototype } checkedLink={{}} />;
            }
        });

        expect(() => {
            vrdom.render(<ValueLinkComponent />, document.createElement("div"));
        }).not.toThrow();
    });

});
/* eslint-env node, jasmine */
/* eslint-disable no-undefined, class-methods-use-this, no-magic-numbers */

describe("control-select-prod", () => {
    "use strict";

    var vrdom;
    var Triggers;
    var emptyFn = Function.prototype;

    function expectSelectedIndexes(selectedIndexes, childNodes) {
        selectedIndexes.forEach((i) => {
            expect(childNodes[i].selected).toBe(true);
        });
    }

    beforeAll((done) => {
        window.require.undef("vrdom");

        require(["vrdom", "Triggers"], function() {
            vrdom = arguments[0];
            Triggers = arguments[1](vrdom);

            done();
        });
    });

    afterAll(() => {
        vrdom.reset();
    });

    it("should handle value", () => {
        var values = ["string", "", " ", 0, 1, 1.2];
        var options = values.map((value) => {
            return <option value={ value }>{ value }</option>;
        });

        test(options);
        test(options, true);

        function test(options, optgroup) {
            if (optgroup) {
                options = vrdom.createElement.apply(vrdom, ["optgroup", { label: "optgroup" }].concat(options));
            }

            var container = document.createElement("div");
            values.forEach(function(value, i) {
                var select = vrdom.createElement.apply(vrdom, ["select", {
                    value: value,
                    readOnly: true
                }].concat(options));

                var domNode = vrdom.render(select, container);
                expect(domNode.value).toBe(String(value));

                var childNodes = optgroup ? domNode.firstChild.childNodes : domNode.childNodes;
                expect(childNodes[i].selected).toBe(true);

                vrdom.unmountComponentAtNode(container);
            });
        }
    });

    it("should handle value with multiple", () => {
        var values = ["string", "", " ", 0, 1, 1.2];
        var options = values.map((value) => {
            return <option value={ value }>{ value }</option>;
        });

        test(options);
        test(options, true);

        function test(options, optgroup) {
            if (optgroup) {
                options = vrdom.createElement.apply(vrdom, ["optgroup", { label: "optgroup" }].concat(options));
            }

            var container = document.createElement("div");
            var len = values.length;
            values.forEach(function(value, i) {
                var selectedIndexes;
                if (i < len - 1) {
                    selectedIndexes = [i, i + 1];
                } else {
                    selectedIndexes = [i - 1, i];
                }

                var select = vrdom.createElement.apply(vrdom, ["select", {
                    multiple: true,
                    value: selectedIndexes.map((i) => { return values[i]; }),
                    readOnly: true
                }].concat(options));
                var domNode = vrdom.render(select, container);

                var childNodes = optgroup ? domNode.firstChild.childNodes : domNode.childNodes;

                selectedIndexes.forEach((i) => {
                    expect(childNodes[i].selected).toBe(true);
                });

                vrdom.unmountComponentAtNode(container);
            });
        }
    });

    it("should handle defaultValue", () => {
        var values = ["string", "new", " ", "another", 0, 1, 1.2];
        var options = values.map((value) => {
            return <option value={ value }>{ value }</option>;
        });

        test(options);
        test(options, true);
        vrdom.reset();

        function test(options, optgroup) {
            if (optgroup) {
                options = vrdom.createElement.apply(vrdom, ["optgroup", { label: "optgroup" }].concat(options));
            }

            var container = document.createElement("div");
            var len = values.length;
            values.forEach(function(defaultValue, i) {
                var selectedIndex, select, domNode, childNodes, nextIndex, nextDefaultValue, nextValue;

                selectedIndex = i;
                select = vrdom.createElement.apply(vrdom, ["select", {
                    defaultValue: defaultValue
                }].concat(options));
                domNode = vrdom.render(select, container);
                childNodes = optgroup ? domNode.firstChild.childNodes : domNode.childNodes;

                expect(domNode.value).toBe(String(defaultValue));
                expect(childNodes[selectedIndex].selected).toBe(true);
                expect(domNode.defaultValue).toBe(String(defaultValue));

                // updating default value should keep previous value
                nextIndex = i < len - 1 ? i + 1 : i - 1;
                nextDefaultValue = values[nextIndex];
                select = vrdom.createElement.apply(vrdom, ["select", {
                    defaultValue: nextDefaultValue
                }].concat(options));
                domNode = vrdom.render(select, container);
                expect(domNode.value).toBe(String(defaultValue));
                expect(childNodes[selectedIndex].selected).toBe(true);
                expect(domNode.defaultValue).toBe(String(nextDefaultValue));

                nextValue = nextDefaultValue;
                selectedIndex = nextIndex;
                select = vrdom.createElement.apply(vrdom, ["select", {
                    value: nextValue,
                    onChange: emptyFn
                }].concat(options));
                domNode = vrdom.render(select, container);
                expect(domNode.value).toBe(String(nextValue));
                expect(childNodes[selectedIndex].selected).toBe(true);

                nextDefaultValue = i < len - 3 ? values[i + 3] : values[i - 3];
                select = vrdom.createElement.apply(vrdom, ["select", {
                    defaultValue: nextDefaultValue,
                }].concat(options));
                domNode = vrdom.render(select, container);
                expect(domNode.value).toBe(String(nextValue));
                expect(childNodes[selectedIndex].selected).toBe(true);
                expect(domNode.defaultValue).toBe(String(nextDefaultValue));

                vrdom.unmountComponentAtNode(container);
            });
        }
    });

    it("should handle defaultValue with multiple", () => {
        var values = ["string", "new", " ", "another", 0, 1, 1.2];
        var options = values.map((value) => {
            return <option value={ value }>{ value }</option>;
        });

        test(options);
        test(options, true);
        vrdom.reset();

        function test(options, optgroup) {
            if (optgroup) {
                options = vrdom.createElement.apply(vrdom, ["optgroup", { label: "optgroup" }].concat(options));
            }

            var len = values.length;
            var container = document.createElement("div");
            values.forEach(function(defaultValue, i) {
                var select, domNode, childNodes, selectedIndexes, nextValue, nextDefaultValue, nextIndexes;

                if (i < len - 1) {
                    selectedIndexes = [i, i + 1];
                } else {
                    selectedIndexes = [i - 1, i];
                }

                select = vrdom.createElement.apply(vrdom, ["select", {
                    multiple: true,
                    defaultValue: selectedIndexes.map((i) => { return values[i]; })
                }].concat(options));
                domNode = vrdom.render(select, container);
                childNodes = optgroup ? domNode.firstChild.childNodes : domNode.childNodes;
                expectSelectedIndexes(selectedIndexes, childNodes);

                // updating default value should keep previous value
                nextIndexes = i < len - 2 ? [i + 1, i + 2] : [i - 2, i - 1];
                nextDefaultValue = nextIndexes.map((i) => { return values[i]; });
                select = vrdom.createElement.apply(vrdom, ["select", {
                    multiple: true,
                    defaultValue: nextDefaultValue
                }].concat(options));
                domNode = vrdom.render(select, container);
                expectSelectedIndexes(selectedIndexes, childNodes);

                nextValue = nextDefaultValue;
                selectedIndexes = nextIndexes;
                nextIndexes = i < len - 3 ? [i + 2, i + 3] : [i - 3, i - 2];
                select = vrdom.createElement.apply(vrdom, ["select", {
                    multiple: true,
                    defaultValue: nextIndexes.map((i) => { return values[i]; }),
                    value: nextValue,
                    onChange: emptyFn
                }].concat(options));
                domNode = vrdom.render(select, container);
                expectSelectedIndexes(selectedIndexes, childNodes);

                nextIndexes = i < len - 4 ? [i + 3, i + 4] : [i - 4, i - 3];
                nextDefaultValue = nextIndexes.map((i) => { return values[i]; });
                select = vrdom.createElement.apply(vrdom, ["select", {
                    multiple: true,
                    defaultValue: nextDefaultValue,
                }].concat(options));
                domNode = vrdom.render(select, container);
                expectSelectedIndexes(selectedIndexes, childNodes);

                vrdom.unmountComponentAtNode(container);
            });
        }
    });

    it("should not change previously setted value when setting defaultValue", () => {
        var values = ["string", "new", " ", "another", 0, 1, 1.2];
        var options = values.map((value) => {
            return <option value={ value }>{ value }</option>;
        });

        test(options);
        test(options, true);

        function test(options, optgroup) {
            if (optgroup) {
                options = vrdom.createElement.apply(vrdom, ["optgroup", { label: "optgroup" }].concat(options));
            }

            var container = document.createElement("div");
            var select = vrdom.createElement.apply(vrdom, ["select", null].concat(options));
            var domNode = vrdom.render(select, container);

            domNode.value = String(values[4]);
            select = vrdom.createElement.apply(vrdom, ["select", {
                defaultValue: values[5]
            }].concat(options));
            domNode = vrdom.render(select, container);
            expect(domNode.value).toBe(String(values[4]));
            expect(domNode.defaultValue).toBe(String(values[5]));
            vrdom.unmountComponentAtNode(container);

            select = vrdom.createElement.apply(vrdom, ["select", {
                value: values[6],
                readOnly: true
            }].concat(options));
            domNode = vrdom.render(select, container);
            expect(domNode.value).toBe(String(values[6]));

            select = vrdom.createElement.apply(vrdom, ["select", {
                defaultValue: values[1]
            }].concat(options));
            domNode = vrdom.render(select, container);
            expect(domNode.value).toBe(String(values[6]));
            expect(domNode.defaultValue).toBe(String(values[1]));

            vrdom.unmountComponentAtNode(container);
        }
    });

    it("should not change previously setted value when setting defaultValue multiple", () => {
        var values = ["string", "new", " ", "another", 0, 1, 1.2];
        var options = values.map((value) => {
            return <option value={ value }>{ value }</option>;
        });

        test(options);
        test(options, true);

        function test(options, optgroup) {
            if (optgroup) {
                options = vrdom.createElement.apply(vrdom, ["optgroup", { label: "optgroup" }].concat(options));
            }

            var container = document.createElement("div");
            var select = vrdom.createElement.apply(vrdom, ["select", { multiple: true }].concat(options));
            var domNode = vrdom.render(select, container);
            var childNodes = optgroup ? domNode.firstChild.childNodes : domNode.childNodes;

            var selectedIndexes = [1, 2];
            var defaultIndexes = [3, 4];

            selectedIndexes.forEach((i) => {
                childNodes[i].selected = true;
            });

            select = vrdom.createElement.apply(vrdom, ["select", {
                multiple: true,
                defaultValue: defaultIndexes.map((i) => { return values[i]; })
            }].concat(options));
            domNode = vrdom.render(select, container);
            expectSelectedIndexes(selectedIndexes, childNodes);
            vrdom.unmountComponentAtNode(container);

            select = vrdom.createElement.apply(vrdom, ["select", {
                multiple: true,
                value: selectedIndexes.map((i) => { return values[i]; }),
                readOnly: true
            }].concat(options));
            domNode = vrdom.render(select, container);
            childNodes = optgroup ? domNode.firstChild.childNodes : domNode.childNodes;
            expectSelectedIndexes(selectedIndexes, childNodes);

            select = vrdom.createElement.apply(vrdom, ["select", {
                multiple: true,
                defaultValue: defaultIndexes.map((i) => { return values[i]; })
            }].concat(options));
            domNode = vrdom.render(select, container);
            expectSelectedIndexes(selectedIndexes, childNodes);

            vrdom.unmountComponentAtNode(container);
        }
    });

    it("should control select with value as read only select", () => {
        var values = ["string", "new", " ", "another", 0, 1, 1.2];
        var options = values.map((value) => {
            return <option value={ value }>{ value }</option>;
        });

        test(options);
        test(options, true);

        function test(options, optgroup) {
            if (optgroup) {
                options = vrdom.createElement.apply(vrdom, ["optgroup", { label: "optgroup" }].concat(options));
            }

            var container = document.createElement("div");
            var select = vrdom.createElement.apply(vrdom, ["select", {
                value: values[1]
            }].concat(options));
            var domNode = vrdom.render(select, container);
            expect(domNode.value).toBe(String(values[1]));

            domNode.value = String(values[0]);
            Triggers.change(domNode);
            expect(domNode.value).toBe(String(values[1]));

            domNode.value = String(values[0]);
            Triggers.change(domNode);
            expect(domNode.value).toBe(String(values[1]));

            vrdom.unmountComponentAtNode(container);
        }
    });

    it("should control select with value as read only select multiple", () => {
        var values = ["string", "new", " ", "another", 0, 1, 1.2];
        var options = values.map((value) => {
            return <option value={ value }>{ value }</option>;
        });

        test(options);
        test(options, true);

        function test(options, optgroup) {
            if (optgroup) {
                options = vrdom.createElement.apply(vrdom, ["optgroup", { label: "optgroup" }].concat(options));
            }

            var container = document.createElement("div");
            var selectedIndexes = [1, 2];

            var select = vrdom.createElement.apply(vrdom, ["select", {
                multiple: true,
                value: selectedIndexes.map((i) => { return values[i]; })
            }].concat(options));
            var domNode = vrdom.render(select, container);
            var childNodes = optgroup ? domNode.firstChild.childNodes : domNode.childNodes;
            expectSelectedIndexes(selectedIndexes, childNodes);

            [3, 4].forEach((i) => {
                childNodes[i].selected = true;
            });
            Triggers.change(domNode);
            expectSelectedIndexes(selectedIndexes, childNodes);

            [0, 5].forEach((i) => {
                childNodes[i].selected = true;
            });
            Triggers.change(domNode);
            expectSelectedIndexes(selectedIndexes, childNodes);
        
            vrdom.unmountComponentAtNode(container);
        }
    });

    it("should control select", () => {
        var values = ["string", "new", " ", "another", 0, 1, 1.2];
        var options = values.map((value) => {
            return <option value={ value }>{ value }</option>;
        });

        test(options);
        test(options, true);

        function test(options, optgroup) {
            if (optgroup) {
                options = vrdom.createElement.apply(vrdom, ["optgroup", { label: "optgroup" }].concat(options));
            }

            class Component extends vrdom.Component {
                constructor(props, context) {
                    super(props, context);
                    this.handleChange = this.handleChange.bind(this);
                    this.state = { value: values[1] };
                }

                handleChange(evt) {
                    this.setState({ value: evt.target.value });
                }

                render() {
                    return vrdom.createElement.apply(vrdom, ["select", {
                        value: this.state.value,
                        onChange: this.handleChange
                    }].concat(options));
                }
            }

            var container = document.createElement("div");
            var instance = vrdom.render(<Component />, container);
            var domNode = vrdom.findDOMNode(instance);

            expect(domNode.value).toBe(String(values[1]));

            domNode.value = String(values[3]);
            Triggers.change(domNode);
            expect(domNode.value).toBe(String(values[3]));

            domNode.value = String(values[4]);
            Triggers.change(domNode);
            expect(domNode.value).toBe(String(values[4]));

            domNode.value = String(values[5]);
            Triggers.change(domNode);
            expect(domNode.value).toBe(String(values[5]));

            vrdom.unmountComponentAtNode(container);
        }
    });

    it("should control select multiple", () => {
        var values = ["string", "new", " ", "another", 0, 1, 1.2];
        var options = values.map((value) => {
            return <option value={ value }>{ value }</option>;
        });

        test(options);
        test(options, true);

        function test(options, optgroup) {
            if (optgroup) {
                options = vrdom.createElement.apply(vrdom, ["optgroup", { label: "optgroup" }].concat(options));
            }

            var selectedIndexes = [1, 2];

            class Component extends vrdom.Component {
                constructor(props, context) {
                    super(props, context);
                    this.handleChange = this.handleChange.bind(this);
                    this.state = { value: selectedIndexes.map((i) => { return values[i]; }) };
                }

                handleChange(evt) {
                    var values = [];
                    var options = evt.target.options;
                    for (var i = 0, len = options.length; i < len; i++) {
                        if (options[i].selected) {
                            values.push(options[i].value);
                        }
                    }

                    this.setState({ value: values });
                }

                render() {
                    return vrdom.createElement.apply(vrdom, ["select", {
                        multiple: true,
                        value: this.state.value,
                        onChange: this.handleChange
                    }].concat(options));
                }
            }

            var container = document.createElement("div");
            var instance = vrdom.render(<Component />, container);
            var domNode = vrdom.findDOMNode(instance);
            var childNodes = optgroup ? domNode.firstChild.childNodes : domNode.childNodes;

            expectSelectedIndexes(selectedIndexes, childNodes);

            selectedIndexes = [0, 3];
            selectedIndexes.forEach((i) => {
                childNodes[i].selected = true;
            });
            Triggers.change(domNode);
            expectSelectedIndexes(selectedIndexes, childNodes);

            selectedIndexes = [4, 5];
            selectedIndexes.forEach((i) => {
                childNodes[i].selected = true;
            });
            Triggers.change(domNode);
            expectSelectedIndexes(selectedIndexes, childNodes);

            selectedIndexes = [1, 3];
            selectedIndexes.forEach((i) => {
                childNodes[i].selected = true;
            });
            Triggers.change(domNode);
            expectSelectedIndexes(selectedIndexes, childNodes);

            vrdom.unmountComponentAtNode(container);
        }
    });

    it("should set/unset multiple", () => {
        var values = ["string", "new", " ", "another", 0, 1, 1.2];
        var options = values.map((value) => {
            return <option value={ value }>{ value }</option>;
        });

        test(options);
        test(options, true);

        function test(options, optgroup) {
            if (optgroup) {
                options = vrdom.createElement.apply(vrdom, ["optgroup", { label: "optgroup" }].concat(options));
            }

            var container = document.createElement("div");
            var selectedIndexes = [1, 2];

            // multiple to not multiple
            var select = vrdom.createElement.apply(vrdom, ["select", {
                multiple: true,
                defaultValue: selectedIndexes.map((i) => { return values[i]; })
            }].concat(options));
            var domNode = vrdom.render(select, container);
            var childNodes = optgroup ? domNode.firstChild.childNodes : domNode.childNodes;

            expectSelectedIndexes(selectedIndexes, childNodes);

            select = vrdom.createElement.apply(vrdom, ["select", {
                defaultValue: values[3]
            }].concat(options));
            domNode = vrdom.render(select, container);
            expect(domNode.value).toBe(String(values[3]));

            vrdom.unmountComponentAtNode(container);

            // not multiple to multiple
            select = vrdom.createElement.apply(vrdom, ["select", {
                defaultValue: values[3]
            }].concat(options));
            domNode = vrdom.render(select, container);
            childNodes = optgroup ? domNode.firstChild.childNodes : domNode.childNodes;
            expect(domNode.value).toBe(String(values[3]));

            select = vrdom.createElement.apply(vrdom, ["select", {
                multiple: true,
                defaultValue: selectedIndexes.map((i) => { return values[i]; })
            }].concat(options));
            domNode = vrdom.render(select, container);
            expectSelectedIndexes(selectedIndexes, childNodes);

            vrdom.unmountComponentAtNode(container);

            select = vrdom.createElement.apply(vrdom, ["select", {
                multiple: true,
                defaultValue: selectedIndexes.map((i) => { return values[i]; })
            }].concat(options));
            domNode = vrdom.render(select, container);
            childNodes = optgroup ? domNode.firstChild.childNodes : domNode.childNodes;
            expectSelectedIndexes(selectedIndexes, childNodes);

            select = vrdom.createElement.apply(vrdom, ["select", {
                defaultValue: values[3]
            }].concat(options));
            domNode = vrdom.render(select, container);
            expect(domNode.value).toBe(String(values[3]));

            select = vrdom.createElement.apply(vrdom, ["select", {
                multiple: true,
                defaultValue: selectedIndexes.map((i) => { return values[i]; })
            }].concat(options));
            domNode = vrdom.render(select, container);
            expectSelectedIndexes(selectedIndexes, childNodes);

            select = vrdom.createElement.apply(vrdom, ["select", {
                defaultValue: values[3]
            }].concat(options));
            domNode = vrdom.render(select, container);
            expect(domNode.value).toBe(String(values[3]));

            vrdom.unmountComponentAtNode(container);
        }
    });

    it("should control if disabled", () => {
        var container = document.createElement("div");

        vrdom.render(
            <select value="void" disabled>
                <optgroup>
                    <option value="value">value</option>
                    <option value="void">void</option>
                </optgroup>
            </select>
        , container);
        expect(container.firstChild.firstChild.childNodes[0].selected).toBe(false);
        expect(container.firstChild.firstChild.childNodes[1].selected).toBe(true);

        vrdom.render(
            <select value="value" disabled>
                <optgroup>
                    <option value="value">value</option>
                    <option value="void">void</option>
                </optgroup>
            </select>
        , container);
        expect(container.firstChild.firstChild.childNodes[0].selected).toBe(true);
        expect(container.firstChild.firstChild.childNodes[1].selected).toBe(false);
    });

    it("should not warn if value is null", () => {
        spyOn(console, "error");

        var container = document.createElement("div");
        vrdom.render(
            <select value={ null }>
                <optgroup>
                    <option value="value">value</option>
                    <option value="void">void</option>
                </optgroup>
            </select>
        , container);

        expect(console.error.calls.count()).toBe(0);
    });

    it("should not warn if value change from uncontrolled to controlled", () => {
        spyOn(console, "error");

        var container = document.createElement("div");
        vrdom.render(
            <select defaultValue="void">
                <optgroup>
                    <option value="value">value</option>
                    <option value="void">void</option>
                </optgroup>
            </select>
        , container);
        vrdom.render(
            <select value="value" onChange={ Function.prototype }>
                <optgroup>
                    <option value="value">value</option>
                    <option value="void">void</option>
                </optgroup>
            </select>
        , container);

        expect(console.error.calls.count()).toBe(0);

        vrdom.reset();
    });

    it("should not warn if value change from controlled to uncontrolled", () => {
        spyOn(console, "error");

        var container = document.createElement("div");
        vrdom.render(
            <select value="value" onChange={ Function.prototype }>
                <optgroup>
                    <option value="value">value</option>
                    <option value="void">void</option>
                </optgroup>
            </select>
        , container);
        vrdom.render(
            <select defaultValue="void">
                <optgroup>
                    <option value="value">value</option>
                    <option value="void">void</option>
                </optgroup>
            </select>
        , container);

        expect(console.error.calls.count()).toBe(0);

        vrdom.reset();
    });

});
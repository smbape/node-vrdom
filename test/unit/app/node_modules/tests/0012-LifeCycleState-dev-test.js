/* eslint-env node, jasmine */
/* eslint-disable no-undefined, class-methods-use-this, no-invalid-this */

describe("LifeCycleState-dev", () => {
    "use strict";

    var vrdom;

    var hasProp = Object.prototype.hasOwnProperty;
    var slice = Array.prototype.slice;
    var LoggerComponent;

    function logger(msg) {
        return function() {
            var state;
            if (this.state == null) {
                state = this.state;
            } else {
                state = defaults({}, this.state);
            }
            this.props.logs.push([this.constructor.displayName || this.constructor.name, msg, state, slice.call(arguments)]);
            return true;
        };
    }

    function isObject(obj) {
        return obj && ("object" === typeof obj || "function" === typeof obj);
    }

    function defaults(dst, src) {
        var prop;
        if (!isObject(dst) || !isObject(src)) {
            return dst;
        }
        for (prop in src) {
            if (!hasProp.call(src, prop)) {
                continue;
            }
            if (!hasProp.call(dst, prop)) {
                dst[prop] = src[prop];
            }
        }
        return dst;
    }

    beforeAll((done) => {
        require.undef("vrdom-dev");

        require(["vrdom-dev"], function() {
            vrdom = arguments[0];

            var Component = vrdom.Component;

            LoggerComponent = class extends Component {
                constructor(props) {
                    super(props);
                    logger("constructor").call(this);
                    this.setRef = logger("setRef").bind(this);
                }

                render() {
                    logger("render").call(this);
                    return <div ref={ this.setRef } />;
                }

                setState(state, callback) {
                    var args = slice.call(arguments);

                    if ("function" !== typeof callback) {
                        args[1] = logger("setState-cb").bind(this, state);
                    }

                    Component.prototype.setState.apply(this, args);
                }

                forceUpdate(callback) {
                    if ("function" !== typeof callback) {
                        callback = logger("forceUpdate-cb").bind(this);
                    }

                    Component.prototype.forceUpdate.call(this, callback);
                }
            };

            LoggerComponent.prototype.componentWillMount = logger("componentWillMount");
            LoggerComponent.prototype.componentDidMount = logger("componentDidMount");
            LoggerComponent.prototype.componentWillReceiveProps = logger("componentWillReceiveProps");
            LoggerComponent.prototype.shouldComponentUpdate = logger("shouldComponentUpdate");
            LoggerComponent.prototype.componentWillUpdate = logger("componentWillUpdate");
            LoggerComponent.prototype.componentDidUpdate = logger("componentDidUpdate");
            LoggerComponent.prototype.componentWillUnmount = logger("componentWillUnmount");

            done();
        });
    });

    afterAll(() => {
        vrdom.reset();
    });

    it("should handle multiple setState/replaceState/forceUpdate", () => {
        var MessyComponent = vrdom.createClass({
            displayName: "MessyComponent",

            getInitialState: function() {
                logger("getInitialState").apply(this, arguments);
                this.setRef = logger("setRef").bind(this);
                return {step: "initial"};
            },

            componentWillMount: function() {
                logger("willMount-start").apply(this, arguments);

                this.setState(function(nextState, nextProps) {
                    logger("setState-willMount-0").call(this, defaults({}, nextState), defaults({}, nextProps));
                }, logger("setState-willMount-0-cb"));

                this.setState({ step: "willMount-1" });

                this.setState(function(nextState, nextProps) {
                    logger("setState-willMount-1").call(this, defaults({}, nextState), defaults({}, nextProps));
                }, logger("setState-willMount-1-cb"));

                this.setState({ step: "willMount-2" });

                this.setState(function(nextState, nextProps) {
                    logger("setState-willMount-2").call(this, defaults({}, nextState), defaults({}, nextProps));
                }, logger("setState-willMount-2-cb"));

                logger("willMount-end").apply(this, arguments);
            },

            render: function() {
                logger("render").call(this);
                return <div ref={ this.setRef }>{ this.state.step }</div>;
            },

            componentDidMount: function() {
                logger("didMount-start").apply(this, arguments);
                this.setState({step: "didMount"});
                logger("didMount-end").apply(this, arguments);
            },

            componentWillReceiveProps: function() {
                logger("willReceiveProps-start").apply(this, arguments);

                this.setState(function(nextState, nextProps) {
                    logger("setState-willReceiveProps-0").call(this, defaults({}, nextState), defaults({}, nextProps));
                    return {step: nextProps.step};
                }, logger("setState-willReceiveProps-0-cb"));

                this.replaceState({step: "replaceState-willReceiveProps"});

                this.setState(function(nextState, nextProps) {
                    logger("setState-willReceiveProps-1").call(this, defaults({}, nextState), defaults({}, nextProps));
                    return {step: nextProps.step};
                }, logger("setState-willReceiveProps-1-cb"));

                this.setState(function(nextState, nextProps) {
                    logger("setState-willReceiveProps-2").call(this, defaults({}, nextState), defaults({}, nextProps));
                }, logger("setState-willReceiveProps-2-cb"));

                logger("willReceiveProps-end").apply(this, arguments);
            },

            componentDidUpdate: function() {
                if (this.state.step === "update-state") {
                    logger("didUpdate-start").apply(this, arguments);
                    this.setState({step: "didUpdate"});
                    logger("didUpdate-end").apply(this, arguments);
                } else {
                    logger("componentDidUpdate").apply(this, arguments);
                }
            },

            componentWillUnmount: function() {
                logger("componentWillUnmount").apply(this, arguments);
                // should be ignored
                this.setState({step: "unmount"});
            }

        });

        defaults(MessyComponent.prototype, LoggerComponent.prototype);
        MessyComponent.prototype.setState = LoggerComponent.prototype.setState;
        MessyComponent.prototype.forceUpdate = LoggerComponent.prototype.forceUpdate;

        var createClassReplaceState = MessyComponent.prototype.replaceState;
        MessyComponent.prototype.replaceState = function(state, callback) {
            if ("function" !== typeof callback) {
                callback = logger("replaceState-cb").bind(this, defaults({}, state));
            }

            createClassReplaceState.call(this, state, callback);
        };

        var logs = [];
        var container = document.createElement("div");
        var instance = vrdom.render(<MessyComponent logs={ logs } />, container);
        expect(container.firstChild.innerHTML).toBe("didMount");
        expectLogs(logs, [
            // Initialization start
            // ================================
            ["MessyComponent", "getInitialState", null, []],
            ["MessyComponent", "willMount-start", { step: "initial" }, []],
            ["MessyComponent", "willMount-end", { step: "initial" }, []],
            ["MessyComponent", "setState-willMount-0", { step: "initial" }, [{ step: "initial" }, { logs }]],
            ["MessyComponent", "setState-willMount-1", { step: "initial" }, [{ step: "willMount-1" }, { logs }]],
            ["MessyComponent", "setState-willMount-2", { step: "initial" }, [{ step: "willMount-2" }, { logs }]],
            ["MessyComponent", "render", { step: "willMount-2" }, []],
            ["MessyComponent", "setRef", { step: "willMount-2" }, [jasmine.any(HTMLElement), "mount"]], // setRef should be called just after rendered element is mounted
            ["MessyComponent", "didMount-start", { step: "willMount-2" }, []],
            ["MessyComponent", "didMount-end", { step: "willMount-2" }, []],
            ["MessyComponent", "setState-willMount-0-cb", { step: "willMount-2" }, []],
            ["MessyComponent", "setState-cb", { step: "willMount-2" }, [{ step: "willMount-1" }]],
            ["MessyComponent", "setState-willMount-1-cb", { step: "willMount-2" }, []],
            ["MessyComponent", "setState-cb", { step: "willMount-2" }, [{ step: "willMount-2" }]],
            ["MessyComponent", "setState-willMount-2-cb", { step: "willMount-2" }, []],
            // ================================
            // Initialization end

            // setState start
            // ================================
            ["MessyComponent", "shouldComponentUpdate", { step: "willMount-2" }, [{ logs }, { step: "didMount" }, {}]],
            ["MessyComponent", "componentWillUpdate", { step: "willMount-2" }, [{ logs }, { step: "didMount" }, {}]],
            ["MessyComponent", "render", { step: "didMount" }, []],
            ["MessyComponent", "componentDidUpdate", { step: "didMount" }, [{ logs }, { step: "willMount-2" }, {}]],
            ["MessyComponent", "setState-cb", { step: "didMount" }, [{ step: "didMount" }]],
            // ================================
            // setState end
        ]);

        vrdom.render(<MessyComponent logs={ logs } step="update-prop" />, container);
        expect(container.firstChild.innerHTML).toBe("update-prop");
        expectLogs(logs, [
            // Update start
            // ================================
            ["MessyComponent", "willReceiveProps-start", { step: "didMount" }, [{ logs, step: "update-prop" }, {}]],
            ["MessyComponent", "willReceiveProps-end", { step: "didMount" }, [{ logs, step: "update-prop" }, {}]],
            // skipped due to replace state
            // ["MessyComponent", "setState-willReceiveProps-0", { step: "didMount" }, [{ step: "didMount" }, { logs }]],
            ["MessyComponent", "setState-willReceiveProps-1", { step: "didMount" }, [{ step: "replaceState-willReceiveProps" }, { logs, step: "update-prop" }]],
            ["MessyComponent", "setState-willReceiveProps-2", { step: "didMount" }, [{ step: "update-prop" }, { logs, step: "update-prop" }]],
            ["MessyComponent", "shouldComponentUpdate", { step: "didMount" }, [{ logs, step: "update-prop" }, { step: "update-prop" }, {}]],
            ["MessyComponent", "componentWillUpdate", { step: "didMount" }, [{ logs, step: "update-prop" }, { step: "update-prop" }, {}]],
            ["MessyComponent", "render", { step: "update-prop" }, []],
            ["MessyComponent", "componentDidUpdate", { step: "update-prop" }, [{ logs }, { step: "didMount" }, {}]],
            ["MessyComponent", "setState-willReceiveProps-0-cb", { step: "update-prop" }, []],
            ["MessyComponent", "replaceState-cb", { step: "update-prop" }, [{ step: "replaceState-willReceiveProps" }]],
            ["MessyComponent", "setState-willReceiveProps-1-cb", { step: "update-prop" }, []],
            ["MessyComponent", "setState-willReceiveProps-2-cb", { step: "update-prop" }, []],
            // ================================
            // Update end
        ]);

        instance.setState({ step: "update-state" });
        expect(container.firstChild.innerHTML).toBe("didUpdate");
        expectLogs(logs, [
            // setState start
            // ================================
            ["MessyComponent", "shouldComponentUpdate", { step: "update-prop" }, [{ logs, step: "update-prop" }, { step: "update-state" }, {}]],
            ["MessyComponent", "componentWillUpdate", { step: "update-prop" }, [{ logs, step: "update-prop" }, { step: "update-state" }, {}]],
            ["MessyComponent", "render", { step: "update-state" }, []],
            ["MessyComponent", "didUpdate-start", { step: "update-state" }, [{ logs, step: "update-prop" }, { step: "update-prop" }, {}]],
            ["MessyComponent", "didUpdate-end", { step: "update-state" }, [{ logs, step: "update-prop" }, { step: "update-prop" }, {}]],
            ["MessyComponent", "setState-cb", { step: "update-state" }, [{ step: "update-state" }]],
            // ================================
            // setState end

            // setState start
            // ================================
            ["MessyComponent", "shouldComponentUpdate", { step: "update-state" }, [{ logs, step: "update-prop" }, { step: "didUpdate" }, {}]],
            ["MessyComponent", "componentWillUpdate", { step: "update-state" }, [{ logs, step: "update-prop" }, { step: "didUpdate" }, {}]],
            ["MessyComponent", "render", { step: "didUpdate" }, []],
            ["MessyComponent", "componentDidUpdate", { step: "didUpdate" }, [{ logs, step: "update-prop" }, { step: "update-state" }, {}]],
            ["MessyComponent", "setState-cb", { step: "didUpdate" }, [{ step: "didUpdate" }]],
            // ================================
            // setState end
        ]);

        instance.forceUpdate();
        expect(container.firstChild.innerHTML).toBe("didUpdate");
        expectLogs(logs, [
            // forceUpdate start
            // ================================
            ["MessyComponent", "componentWillUpdate", { step: "didUpdate" }, [{ logs, step: "update-prop" }, { step: "didUpdate" }, {}]],
            ["MessyComponent", "render", { step: "didUpdate" }, []],
            ["MessyComponent", "componentDidUpdate", { step: "didUpdate" }, [{ logs, step: "update-prop" }, { step: "didUpdate" }, {}]],
            ["MessyComponent", "forceUpdate-cb", { step: "didUpdate" }, []],
            // ================================
            // forceUpdate end
        ]);

        vrdom.unmountComponentAtNode(container);
        expectLogs(logs, [
            // Destruction start
            // ================================
            // Before unmounting, any tasks done in componenentDidMount/componentDidUpdate
            // should be undone first.
            // Therefore, componentWillUnmount is called first.
            ["MessyComponent", "componentWillUnmount", { step: "didUpdate" }, []],

            // Then children should be destroyed.
            // To prevent ref owner from using child after destruction,
            // ref should be set to null before starting child destruction.
            ["MessyComponent", "setRef", { step: "didUpdate" }, [null, "unmount"]],
            // ================================
            // Destruction end
        ]);

        function expectLogs(logs, expected) {
            // for better failure message
            expect(logs.length).toBe(expected.length);
            for (let i = 0, len = expected.length; i < len; i++) {
                expect(logs[i]).toHaveSameItemsAs(expected[i]);
            }
            logs.length = 0;
        }
    });

});
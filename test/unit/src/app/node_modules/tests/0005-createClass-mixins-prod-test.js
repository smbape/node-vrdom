/* eslint-env node, jasmine */
/* eslint-disable no-undefined, class-methods-use-this */

describe("createClass-mixins-prod", () => {
    "use strict";

    // IE9 do not respect use strict undefined this

    var vrdom;
    var ComponentClass;

    var hasProp = Object.prototype.hasOwnProperty;

    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Polyfill
    var assign = typeof Object.assign === "function" ? Object.assign : function(target) {
        if (target == null) { // TypeError if undefined or null
            throw new TypeError("Cannot convert undefined or null to object");
        }

        var to = Object(target);

        for (var index = 1, len = arguments.length; index < len; index++) {
            var nextSource = arguments[index];

            if (nextSource != null) { // Skip over if undefined or null
                for (var nextKey in nextSource) {
                    // Abugs when hasOwnProperty is shadowed
                    if (hasProp.call(nextSource, nextKey)) {
                        to[nextKey] = nextSource[nextKey];
                    }
                }
            }
        }
        return to;
    };

    function createMixin(name, displayName, properties) {

        var statics = {};
        statics.static = "static" + name;
        statics["static" + name] = "static" + name;

        var defaultProps = {};
        defaultProps.prop = "prop" + name;
        defaultProps["prop" + name] = "prop" + name;

        var initialState = {};
        initialState.state = "state" + name;
        initialState["state" + name] = "state" + name;

        var mixin = {
            displayName: displayName,
            statics: statics,
            getDefaultProps: function() {
                return defaultProps;
            },
            getInitialState: function() {
                if (this && this.props) {
                    this.props.logs.push(displayName + " getInitialState");
                }
                return initialState;
            },
            render: function() {
                if (this && this.props) {
                    this.props.logs.push(displayName + " render");
                }
                return <div />;
            },
            componentWillMount: function() {
                if (this && this.props) {
                    this.props.logs.push(displayName + " componentWillMount");
                }
                return this === window ? undefined : this;
            },
            componentDidMount: function() {
                if (this && this.props) {
                    this.props.logs.push(displayName + " componentDidMount");
                }
                return this === window ? undefined : this;
            },
            componentWillReceiveProps: function() {
                if (this && this.props) {
                    this.props.logs.push(displayName + " componentWillReceiveProps");
                }
                return this === window ? undefined : this;
            },
            shouldComponentUpdate: function() {
                if (this && this.props) {
                    this.props.logs.push(displayName + " shouldComponentUpdate");
                }
            },
            componentWillUpdate: function() {
                if (this && this.props) {
                    this.props.logs.push(displayName + " componentWillUpdate");
                }
                return this === window ? undefined : this;
            },
            componentDidUpdate: function() {
                if (this && this.props) {
                    this.props.logs.push(displayName + " componentDidUpdate");
                }
                return this === window ? undefined : this;
            },
            componentWillUnmount: function() {
                if (this && this.props) {
                    this.props.logs.push(displayName + " componentWillUnmount");
                }
                return this === window ? undefined : this;
            },
            custom: function() {
                if (this && this.props) {
                    this.props.logs.push(displayName + " custom");
                }
                return this === window ? undefined : this;
            }
        };

        mixin["custom" + name] = function() {
            this.props.logs.push(displayName + " custom");
            return this === window ? undefined : this;
        };

        assign(mixin, properties);

        return mixin;
    }

    beforeAll((done) => {
        require.undef("vrdom");

        require(["vrdom"], function() {
            vrdom = arguments[0];

            var MixinA = createMixin("A", "MixinA");
            var MixinB = createMixin("B", "MixinB", { mixins: [MixinA]});
            var MixinC = createMixin("C", "MixinC");

            var Mixin = createMixin("ComponentClass", "ComponentClass", { mixins: [MixinB, MixinC] });
            delete Mixin.statics.static;
            ComponentClass = vrdom.createClass(Mixin);

            done();
        });
    });

    afterAll(() => {
        vrdom.reset();
    });

    it("should merge static properties", () => {
        expect(ComponentClass.displayName).toBe("ComponentClass");
        expect(ComponentClass.static).toBe("staticC");
        expect(ComponentClass.staticA).toBe("staticA");
        expect(ComponentClass.staticB).toBe("staticB");
        expect(ComponentClass.staticC).toBe("staticC");
        expect(ComponentClass.staticComponentClass).toBe("staticComponentClass");
    });

    it("should merge defaultProps", () => {
        var logs = [];
        var element = <ComponentClass logs={logs} />;
        var props = element.props;
        expect(props.prop).toBe("propComponentClass");
        expect(props.propA).toBe("propA");
        expect(props.propB).toBe("propB");
        expect(props.propC).toBe("propC");
        expect(props.propComponentClass).toBe("propComponentClass");
    });

    it("should merge initialState", () => {
        var logs = [];
        var element = <ComponentClass logs={logs} />;
        var instance = new ComponentClass(element.props);
        var state = instance.state;

        expect(state.state).toBe("stateComponentClass");
        expect(state.stateA).toBe("stateA");
        expect(state.stateB).toBe("stateB");
        expect(state.stateC).toBe("stateC");
        expect(state.stateComponentClass).toBe("stateComponentClass");

        expect(logs).toEqual([
            "MixinA getInitialState",
            "MixinB getInitialState",
            "MixinC getInitialState",
            "ComponentClass getInitialState"
        ]);
    });

    it("should keep render method", () => {
        var logs = [];
        var element = <ComponentClass logs={logs} />;
        var instance = new ComponentClass(element.props);

        logs.length = 0;
        instance.render();

        expect(logs).toEqual(["ComponentClass render"]);
    });

    it("should keep shouldComponentUpdate method", () => {
        var logs = [];
        var element = <ComponentClass logs={logs} />;
        var instance = new ComponentClass(element.props);

        logs.length = 0;
        instance.shouldComponentUpdate();

        expect(logs).toEqual(["ComponentClass shouldComponentUpdate"]);
    });

    it("should chain Component Interface methods and not autobind them", () => {
        var logs = [];
        var element = <ComponentClass logs={logs} />;
        var instance = new ComponentClass(element.props);

        var methods = [
            "componentWillMount",
            "componentDidMount",
            "componentWillReceiveProps",
            "componentWillUpdate",
            "componentDidUpdate",
            "componentWillUnmount"
        ];

        for (var i = 0, len = methods.length, method; i < len; i++) {
            method = methods[i];

            logs.length = 0;

            instance[method]();

            expect(logs).toEqual([
                "MixinA " + method,
                "MixinB " + method,
                "MixinC " + method,
                "ComponentClass " + method
            ]);

            logs.length = 0;

            // expect no autobind
            // http://stackoverflow.com/questions/32275135/why-does-babel-rewrite-imported-function-call-to-0-fn
            (0, instance[method])();
            expect(logs).toEqual([]);
        }
    });

    it("should autobind and keep last defined custom properties", () => {
        var logs = [];
        var element = <ComponentClass logs={logs} />;
        var instance = new ComponentClass(element.props);

        logs.length = 0;

        // http://stackoverflow.com/questions/32275135/why-does-babel-rewrite-imported-function-call-to-0-fn
        expect((0, instance.customA)()).toBe(instance);
        expect((0, instance.customB)()).toBe(instance);
        expect((0, instance.customC)()).toBe(instance);
        expect((0, instance.customComponentClass)()).toBe(instance);
        expect((0, instance.custom)()).toBe(instance);

        expect(logs).toEqual([
            "MixinA custom",
            "MixinB custom",
            "MixinC custom",
            "ComponentClass custom",
            "ComponentClass custom"
        ]);
    });

    it("should respect autobind option", ()=> {
        var MixinAutoBinded = {
            autobinded: function() {
                return this === window ? undefined : this;
            }
        };

        var MixinNotAutoBinded = {
            autobind: false,
            notautobinded: function() {
                return this === window ? undefined : this;
            }
        };

        var ComponentNotAutoBinded = vrdom.createClass({
            mixins: [ MixinAutoBinded, MixinNotAutoBinded ],

            autobind: false,

            notbinded: function() {
                return this === window ? undefined : this;
            },

            render: function() {
                return <div />;
            }
        });

        var element = <ComponentNotAutoBinded />;
        var instance = new ComponentNotAutoBinded(element.props);

        // http://stackoverflow.com/questions/32275135/why-does-babel-rewrite-imported-function-call-to-0-fn
        expect((0, instance.autobinded)()).toBe(instance);
        expect((0, instance.notautobinded)()).toBe(undefined);
        expect((0, instance.notbinded)()).toBe(undefined);
    });

    it("should not warn if rebind autobind", () => {
        spyOn(console, "error");

        var logs = [];
        var element = <ComponentClass logs={logs} />;
        var instance = new ComponentClass(element.props);
        instance.custom.bind(null);
        instance.custom.bind(undefined);
        instance.custom.bind(instance);

        // should not warn if context changed
        instance.custom.bind({});
        expect(console.error.calls.count()).toBe(0);

        // should not warn if added argument
        instance.custom.bind(instance, "another argument");
        expect(console.error.calls.count()).toBe(0);
    });

    it("should not keep reference of initialProps", () => {
        var defaultProps = {};

        var Mixin = {
            getDefaultProps: function() {
                return defaultProps;
            }
        };

        var ComponentClass = vrdom.createClass({
            mixins: [Mixin],
            render: function() {
                return <div />;
            }
        });

        var element = <ComponentClass />;
        expect(element.props).not.toBe(defaultProps);
    });

    it("should not keep reference of initialState when chained", () => {
        var mixinInitalState = {};
        var Mixin = {
            getInitialState: function() {
                return mixinInitalState;
            }
        };

        var componentInitialState = {};
        var ComponentClass = vrdom.createClass({
            mixins: [Mixin],
            getInitialState: function() {
                return componentInitialState;
            },
            render: function() {
                return <div />;
            }
        });

        var element = <ComponentClass />;
        var instance = new ComponentClass(element.props);

        expect(instance.state).not.toBe(mixinInitalState);
        expect(instance.state).not.toBe(componentInitialState);
    });

    it("should merge null initialState", () => {
        var ComponentClass, Mixin, element, instance;

        var initialState = { string: "string" };

        Mixin = {
            getInitialState: function() {
                return null;
            }
        };

        ComponentClass = vrdom.createClass({
            mixins: [Mixin],
            getInitialState: function() {
                return initialState;
            },
            render: function() {
                return <div />;
            }
        });

        element = <ComponentClass />;
        instance = new ComponentClass(element.props);
        expect(instance.state.string).toBe(initialState.string);

        Mixin = {
            getInitialState: function() {
                return initialState;
            }
        };

        ComponentClass = vrdom.createClass({
            mixins: [Mixin],
            getInitialState: function() {
                return null;
            },
            render: function() {
                return <div />;
            }
        });

        element = <ComponentClass />;
        instance = new ComponentClass(element.props);
        expect(instance.state.string).toBe(initialState.string);

    });

    it("should ignore undefined mixin", () => {
        spyOn(console, "error");

        vrdom.createClass({
            mixins: undefined,

            render: function() {
                return <div />;
            }
        });

        expect(console.error.calls.count()).toBe(0);
    });

    it("should ignore null mixin", () => {
        spyOn(console, "error");

        vrdom.createClass({
            mixins: null,

            render: function() {
                return <div />;
            }
        });

        expect(console.error.calls.count()).toBe(0);
    });

    it("should not warn if undefined mixin", () => {
        spyOn(console, "error");

        vrdom.createClass({
            mixins: [undefined],

            render: function() {
                return <div />;
            }
        });

        expect(console.error.calls.count()).toBe(0);
    });

    it("should not warn if null mixin", () => {
        spyOn(console, "error");

        vrdom.createClass({
            mixins: [null],

            render: function() {
                return <div />;
            }
        });

        expect(console.error.calls.count()).toBe(0);
    });

    it("should not warn if nested undefined mixin", () => {
        spyOn(console, "error");

        var MixinA = {
            mixins: [undefined]
        };

        vrdom.createClass({
            mixins: [MixinA],

            render: function() {
                return <div />;
            }
        });

        expect(console.error.calls.count()).toBe(0);
    });

    it("should not warn if nested null mixin", () => {
        spyOn(console, "error");

        var MixinA = {
            mixins: [null]
        };

        vrdom.createClass({
            mixins: [MixinA],

            render: function() {
                return <div />;
            }
        });

        expect(console.error.calls.count()).toBe(0);
    });

    it("should not throw if mixin is an element", () => {
        expect(() => {
            vrdom.createClass({
                mixins: [<div />],

                render: function() {
                    return <div />;
                }
            });
        }).not.toThrow();
    });

    it("should not throw if mixin is a Component class", () => {
        expect(() => {
            var ComponentClass = vrdom.createClass({
                render: function() {
                    return <div />;
                }
            });

            vrdom.createClass({
                mixins: [ComponentClass],

                render: function() {
                    return <div />;
                }
            });
        }).not.toThrow();
    });

});
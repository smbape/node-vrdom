/* eslint-env node, jasmine */
/* eslint-disable no-undefined, class-methods-use-this */

describe("Element-prod", () => {
    "use strict";

    var vrdom;
    var ComponentClass;
    var ComponentClassFactory;

    beforeAll((done) => {
        require.undef("vrdom");

        require(["vrdom"], function() {
            vrdom = arguments[0];

            ComponentClass = vrdom.createClass({
                render: function() {
                    return vrdom.createElement("b");
                }
            });

            ComponentClassFactory = vrdom.createFactory(ComponentClass);

            done();
        });
    });

    afterAll(() => {
        vrdom.reset();
    });

    it("should return a plain object", () => {
        var element = ComponentClassFactory();
        expect(element.constructor).toBe(Object.prototype.constructor);
    });

    it("should create element using ComponentClassFactory", () => {
        var element = ComponentClassFactory();
        expect(element.type).toBe(ComponentClass);
        expect(element.key).toBe(null);
        expect(element.ref).toBe(null);
        expect(element.props).toEqual({});
    });

    it("should create element using createFactory(String)", () => {
        var element = vrdom.createFactory("b")();
        expect(element.type).toBe("b");
        expect(element.key).toBe(null);
        expect(element.ref).toBe(null);
        expect(element.props).toEqual({});
    });

    it("should not use the original object as props", () => {
        var config = { a: 0 };
        var element = ComponentClassFactory(config);
        expect(element.props.a).toBe(0);
        config.a = 1;
        expect(element.props.a).toBe(0);
    });

    it("should allow config without prototype", () => {
        var config = Object.create(null, {
            a: {
                value: 0,
                enumerable: true
            }
        });
        var element = ComponentClassFactory(config);
        expect(element.props.a).toBe(0);
    });

    it("should pass key and ref to element and not props", () => {
        var element = ComponentClassFactory({
            key: "a key",
            ref: "a ref",
            a: "a a"
        });

        expect(element.type).toBe(ComponentClass);
        expect(element.key).toBe("a key");
        expect(element.ref).toBe("a ref");
        expect(element.props).toEqual({
            a: "a a"
        });
    });

    it("should cast key as string", () => {
        var element = ComponentClassFactory({
            key: 0,
            a: "a"
        });

        expect(element.type).toBe(ComponentClass);
        expect(element.key).toBe("0");
        expect(element.ref).toBe(null);
        expect(element.props).toEqual({ a: "a" });
    });

    it("should allow null key and ref", () => {
        var element = ComponentClassFactory({
            key: null,
            ref: null,
            a: "a"
        });

        expect(element.type).toBe(ComponentClass);
        expect(element.key).toBe("null");
        expect(element.ref).toBe(null);
        expect(element.props).toEqual({ a: "a" });
    });

    it("should ignore undefined key and ref", () => {
        var props = {
            key: undefined,
            ref: undefined,
            a: "a"
        };

        var element = ComponentClassFactory(props);
        expect(element.type).toBe(ComponentClass);
        expect(element.key).toBe(null);
        expect(element.ref).toBe(null);
        expect(element.props).toEqual({ a: "a" });
    });

    it("should treat arguments after config as children", () => {
        spyOn(console, "error");

        var config = null;
        var children = [1, 2, 3];
        var args = [config].concat(children);
        var element = ComponentClassFactory.apply(undefined, args);
        expect(element.props.children).toEqual(children);

        // check warn for unique key prop
        expect(console.error.calls.count()).toBe(0);
    });

    it("should not change children prop if there are no argument after config", () => {
        spyOn(console, "error");

        var element = ComponentClassFactory({
            children: "a",
        });
        expect(element.props.children).toBe("a");

        // check warn for unique key prop
        expect(console.error.calls.count()).toBe(0);
    });

    it("should override children prop with arguments after config", () => {
        spyOn(console, "error");

        var children = "argument";
        var element = ComponentClassFactory({
            children: "a",
        }, children);
        expect(element.props.children).toBe(children);

        // check warn for unique key prop
        expect(console.error.calls.count()).toBe(0);
    });

    it("should override children prop with arguments after config even if null", () => {
        spyOn(console, "error");

        var element = ComponentClassFactory({
            children: "a",
        }, null);
        expect(element.props.children).toBe(null);

        // check warn for unique key prop
        expect(console.error.calls.count()).toBe(0);
    });

    it("should override children prop with arguments after config even if undefined", () => {
        spyOn(console, "error");

        var element = ComponentClassFactory({
            children: "a",
        }, undefined);
        expect(element.props.children).toBe(undefined);

        // check warn for unique key prop
        expect(console.error.calls.count()).toBe(0);
    });

    it("should not warn for keys when using array of Component as children", () => {
        spyOn(console, "error");

        ComponentClassFactory(null, [ComponentClassFactory()]);

        expect(console.error.calls.count()).toBe(0);
    });

    it("should not warn for keys when using array of element as children", () => {
        spyOn(console, "error");

        var div = vrdom.createFactory("div");

        div(null, [div()]);

        expect(console.error.calls.count()).toBe(0);
    });

    it("should not add owner info in warning for keys", () => {
        spyOn(console, "error");

        // use another name to ensure warning occurs only when an array is used as children

        class Child extends vrdom.Component {
            render() {
                return <div>{ this.props.childNodes }</div>;
            }
        }

        class Parent extends vrdom.Component {
            render() {
                return <Child childNodes={ this.props.childNodes } />;
            }
        }

        class GrandParent extends vrdom.Component {
            render() {
                return <Parent childNodes={ [<Child/>] } />;
            }
        }

        vrdom.render(<GrandParent/>, document.createElement("div"));

        expect(console.error.calls.count()).toBe(0);
    });

});
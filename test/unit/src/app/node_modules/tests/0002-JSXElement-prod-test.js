/* eslint-env node, jasmine */
/* eslint-disable no-undefined, class-methods-use-this */

describe("JSXElement-prod", () => {
    "use strict";

    var vrdom;
    var Component;

    beforeAll((done) => {
        require.undef("vrdom");

        require(["vrdom"], function() {
            vrdom = arguments[0];

            Component = class extends vrdom.Component {
                render() {
                    return <b/>;
                }
            };

            done();
        });
    });

    afterAll(() => {
        vrdom.reset();
    });

    it("should return a plain object", () => {
        var element = <Component/>;
        expect(element.constructor).toBe(Object.prototype.constructor);
    });

    it("should create element using jsx component", () => {
        var element = <Component/>;
        expect(element.type).toBe(Component);
        expect(element.key).toBe(null);
        expect(element.ref).toBe(null);
        expect(element.props).toEqual({});
    });

    it("should create element using jsx element", () => {
        var element = <b/>;
        expect(element.type).toBe("b");
        expect(element.key).toBe(null);
        expect(element.ref).toBe(null);
        expect(element.props).toEqual({});
    });

    it("should not use the original object as props", () => {
        var config = { a: 0 };
        var element = <Component { ...config } />;
        expect(element.props.a).toBe(0);
        config.a = 1;
        expect(element.props.a).toBe(0);
    });

    it("should allow config without prototype", () => {
        var config = Object.create(null, {
            a: {
                value: 1,
                enumerable: true
            }
        });
        var element = <Component { ...config } />;
        expect(element.props.a).toBe(1);
    });

    it("should pass key and ref to element and not props", () => {
        var element = <Component key="a key" ref="a ref" a="a a" />;

        expect(element.type).toBe(Component);
        expect(element.key).toBe("a key");
        expect(element.ref).toBe("a ref");
        expect(element.props).toEqual({ a: "a a" });
    });

    it("should cast key as string", () => {
        var element = <Component key={ 0 } a="a a" />;

        expect(element.type).toBe(Component);
        expect(element.key).toBe("0");
        expect(element.ref).toBe(null);
        expect(element.props).toEqual({ a: "a a" });
    });

    it("should allow null key and ref", () => {
        var element = <Component key={ null } ref={ null } a="a a" />;

        expect(element.type).toBe(Component);
        expect(element.key).toBe("null");
        expect(element.ref).toBe(null);
        expect(element.props).toEqual({ a: "a a" });
    });

    it("should ignore undefined key and ref", () => {
        var element = <Component key={ undefined } ref={ undefined } a="a a" />;

        expect(element.type).toBe(Component);
        expect(element.key).toBe(null);
        expect(element.ref).toBe(null);
        expect(element.props).toEqual({ a: "a a" });
    });

    it("should treat arguments after config as children", () => {
        spyOn(console, "error");

        var children = [1, 2, 3];
        var element = <Component>{children[0]}{children[1]}{children[2]}</Component>;
        expect(element.props.children).toEqual(children);

        // check warn for unique key prop
        expect(console.error.calls.count()).toBe(0);
    });

    it("should not change children prop if there are no argument after config", () => {
        spyOn(console, "error");

        var element = <Component children="a" />;
        expect(element.props.children).toBe("a");

        // check warn for unique key prop
        expect(console.error.calls.count()).toBe(0);
    });

    it("should override children prop with arguments after config", () => {
        spyOn(console, "error");

        var children = "argument";
        var element = <Component children="a">{ children }</Component>;
        expect(element.props.children).toBe(children);

        // check warn for unique key prop
        expect(console.error.calls.count()).toBe(0);
    });

    it("should override children prop with arguments after config even if null", () => {
        spyOn(console, "error");

        var element = <Component children="a">{ null }</Component>;
        expect(element.props.children).toBe(null);

        // check warn for unique key prop
        expect(console.error.calls.count()).toBe(0);
    });

    it("should override children prop with arguments after config even if undefined", () => {
        spyOn(console, "error");

        var element = <Component children="a">{ undefined }</Component>;
        expect(element.props.children).toBe(undefined);

        // check warn for unique key prop
        expect(console.error.calls.count()).toBe(0);
    });

    it("should not warn for keys when using array of Component as children", () => {
        spyOn(console, "error");

        void(<Component children="a">{ [<Component/>] }</Component>); // eslint-disable-line no-void, no-extra-parens

        expect(console.error.calls.count()).toBe(0);
    });

    it("should warn for keys when using array of element as children", () => {
        spyOn(console, "error");

        void(<div>{ [<div/>] }</div>); // eslint-disable-line no-void, no-extra-parens

        expect(console.error.calls.count()).toBe(0);
    });

});
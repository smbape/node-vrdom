/* eslint-env node, jasmine */
/* eslint-disable no-undefined, class-methods-use-this */

describe("keys-dev", () => {
    "use strict";

    var vrdom;

    var slice = Array.prototype.slice;

    beforeAll((done) => {
        require.undef("vrdom-dev");

        require(["vrdom-dev"], function() {
            vrdom = arguments[0];

            done();
        });
    });

    afterAll(() => {
        vrdom.reset();
    });

    it("should use key as children identifiers", () => {
        var container = document.createElement("div");
        var domNode = vrdom.render(<div><div key="A" /></div>, container);
        var childNodes = slice.call(domNode.childNodes);

        vrdom.render(<div><div key="B"/></div>, container);
        var newNodes = slice.call(domNode.childNodes);
        expect(newNodes).not.toHaveEqualItemsAs(childNodes);
        childNodes = newNodes;

        vrdom.render(<div><div key="A" /><div key="B"/></div>, container);
        newNodes = slice.call(domNode.childNodes);
        expect(newNodes).not.toHaveEqualItemsAs(childNodes);
        expect(domNode.childNodes[1]).toBe(childNodes[0]);
    });

    it("should use keys to optimize DOM manipulation", () => {
        function SwapComponent(props) {
            if (props.swap) {
                return (
                    <div>
                        <div key="top">top</div>
                        <div key="bottom">bottom</div>
                        <div>leave me alone</div>
                    </div>
                );
            }

            return (
                <div>
                    <div key="bottom">bottom</div>
                    <div key="top">top</div>
                    <div>leave me alone</div>
                </div>
            );
        }

        var container = document.createElement("div");

        var domNode = vrdom.render(SwapComponent({}), container);

        spyOn(domNode, "insertBefore").and.callThrough();
        spyOn(domNode, "appendChild").and.callThrough();
        spyOn(domNode, "replaceChild").and.callThrough();
        spyOn(domNode, "removeChild").and.callThrough();

        var children0 = slice.call(domNode.childNodes);

        vrdom.render(SwapComponent({swap: true}), container);
        var children1 = slice.call(domNode.childNodes);

        expect(children0[0]).toBe(children1[1]);
        expect(children0[1]).toBe(children1[0]);

        expect(domNode.insertBefore.calls.count()).toBe(1);
        expect(domNode.appendChild.calls.count()).toBe(0);
        expect(domNode.replaceChild.calls.count()).toBe(0);
        expect(domNode.removeChild.calls.count()).toBe(0);
    });

    it("should use keys to optimize DOM manipulation in CompositeComponent", () => {
        class Child extends vrdom.Component {
            render() {
                return <div>{ this.props.children }</div>;
            }
        }

        class Parent extends vrdom.Component {
            render() {
                if (this.props.swap) {
                    return (
                        <div>
                            <Child key="top">top</Child>
                            <Child key="bottom">bottom</Child>
                            <Child>leave me alone</Child>
                        </div>
                    );
                }

                return (
                    <div>
                        <Child key="bottom">bottom</Child>
                        <Child key="top">top</Child>
                        <Child>leave me alone</Child>
                    </div>
                );
            }
        }

        var container = document.createElement("div");
        var instance = vrdom.render(<Parent />, container);
        var domNode = vrdom.findDOMNode(instance);

        spyOn(domNode, "insertBefore").and.callThrough();
        spyOn(domNode, "appendChild").and.callThrough();
        spyOn(domNode, "replaceChild").and.callThrough();
        spyOn(domNode, "removeChild").and.callThrough();

        var children0 = slice.call(domNode.childNodes);

        vrdom.render(<Parent swap={ true } />, container);
        var children1 = slice.call(domNode.childNodes);

        expect(children0[0]).toBe(children1[1]);
        expect(children0[1]).toBe(children1[0]);

        expect(domNode.insertBefore.calls.count()).toBe(1);
        expect(domNode.appendChild.calls.count()).toBe(0);
        expect(domNode.replaceChild.calls.count()).toBe(0);
        expect(domNode.removeChild.calls.count()).toBe(0);
    });

    it("should not add key as DOM attribute", () => {
        var key = "\"><script type=\"text/javascript\">window.shoudNotBeDefined = true;</script><div id=\"";

        class Component extends vrdom.Component {
            render() {
                return <div key={ key }>text</div>;
            }
        }

        var container = document.createElement("div");
        vrdom.render(<Component />, container);
        expect(window).not.toHaveOwnProperty("shoudNotBeDefined");

    });

    it("should warn for duplicated keys", () => {
        spyOn(console, "error");

        class Child extends vrdom.Component {
            render() {
                return <div>{ this.props.children }</div>;
            }
        }

        class Parent extends vrdom.Component {
            render() {
                return <Child>{ this.props.children || [<div key="key"/>, <div key="key"/>] }</Child>;
            }
        }

        var container = document.createElement("div");

        vrdom.render(<Parent>{[<div key="key"/>]}</Parent>, container);
        vrdom.render(<Parent />, container);

        expect(console.error.calls.count()).toBe(1);
        expect(console.error.calls.argsFor(0)[0]).toContain(
            "Warning: flattenChildren(...): duplicate child key prop `key`. Only the first child will be used." +
            " It was used in `Child.render()`." +
            " It was created in `Parent.render()`."
        );
    });
});